* RNA-seq Snakemake Pipelines :biopipe:
:PROPERTIES:
:ID:       2a6a5dac-151e-42e8-a80a-74f77ad0d4ca
:header-args: :tangle no :tangle-mode (identity #o555) :mkdirp yes
:header-args+: :noweb yes
:END:
** Repository administration
*** Github continuous integration
#+begin_src bash :tangle ./.github/workflows/test.yml
name: Snakemake CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Setup Miniconda
      uses: conda-incubator/setup-miniconda@v2
      with:
        miniconda-version: "latest"
        auto-activate-base: true

    - name: Install Mamba
      run: |
        conda install -c conda-forge mamba

    - name: Create Conda Environment
      run: |
        mamba env update -f ./config/rna_env.yaml
#+end_src

*** Conda environmental YAMLs
**** RNA
#+begin_src bash :tangle ./config/rna_env.yaml
name: rna
channels:
  - conda-forge
  - bioconda

dependencies:
  - bedops
  - bedtools
  - bioconductor-GenomicRanges
  - bioconductor-orthology.eg.db
  - bioconductor-TxDb.Mmusculus.UCSC.mm10.ensGene
  - bioconductor-TxDb.Hsapiens.UCSC.hg38.knownGene
  - bioconductor-TxDb.Mmusculus.UCSC.mm10.knownGene
  - bioconductor-complexheatmap
  - bioconductor-deseq2
  - bioconductor-edger
  - bioconductor-fgsea
  - bioconductor-ruvseq
  - bioconductor-rsamtools
  - bioconductor-tximport
  - bowtie2
  - fastp
  - fastqc
  - multiqc
  - pandas
  - parallel
  - r-magick
  - r-ggrepel
  - r-ggextra
  - r-ggsci
  - r-msigdbr
  - r-pheatmap
  - r-rstatix
  - r-ggpattern
  - r-tidyverse
  - r-yaml
  - rseqc
  - samtools
  - snakemake
#+end_src
*** DONE [[id:1a8d792b-9621-42a8-80c9-399b6065630a][Bioinformatics pipeline initial build]]
CLOSED: [2022-10-26 Wed 13:48]
** Development :dev:
*** Version 1.0.0
**** TODO [[id:f6717c79-64ce-4b16-b455-649df2ba20fd][Project stable version update]]
*** Ideas :ideas:
- cibersort
** Ideas
- CPM sex determination https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6947224/
- re-run salmon with decoy-aware index
- get test data
  #+begin_src bash
repo=~/repos/rna-seq
# get salmon files

cp ~/card/inputs/Rentschler_s4630_MGI0042/1-ir.AACATCTCGA-TATTCGCCAG/1-ir.AACATCTCGA-TATTCGCCAG.quant.sf ${repo}/test/inputs/exp1.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/2-ir.GTAACGTCAC-ACCAACTAAG/2-ir.GTAACGTCAC-ACCAACTAAG.quant.sf ${repo}/test/inputs/exp2.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/3-ir.GCTAACCGTG-TCACCATAAG/3-ir.GCTAACCGTG-TCACCATAAG.quant.sf ${repo}/test/inputs/expsample3.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/10-ct.TCATCCGTGA-TTAGGAGGAA/10-ct.TCATCCGTGA-TTAGGAGGAA.quant.sf ${repo}/test/inputs/ctrl.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/9-ct.TCCAGAATGT-TGGTCCAATT/9-ct.TCCAGAATGT-TGGTCCAATT.quant.sf ${repo}/test/inputs/ctrl2.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/8-ct.CCGAACATGT-ACCTCATTGA/8-ct.CCGAACATGT-ACCTCATTGA.quant.sf ${repo}/test/inputs/normal.quant.sf
#+end_src
- file:test/inputs/libraries.tsv
  | library | basename            | participant | run  | group |
  |---------+---------------------+-------------+------+-------|
  | lib001  | ctrl.quant.sf       | subj001     | seq1 | ctrl  |
  | lib002  | ctrl2.quant.sf      | subj002     | seq2 | ctrl  |
  | lib003  | normal.quant.sf     | subj003     | seq1 | ctrl  |
  | lib004  | exp1.quant.sf       | subj004     | seq2 | exp   |
  | lib005  | exp2.quant.sf       | subj005     | seq1 | exp   |
  | lib006  | expsample3.quant.sf | subj006     | seq2 | exp   |
*** Snakemake configuration YAML
#+begin_src bash :tangle ./config/int_test.yaml
experiment_id: inttest_human
txdb: "TxDb.Mmusculus.UCSC.mm10.ensGene",
threads: 4
rna_container: "/home/jeszyman/sing_containers/rna.1.2.0.sif"
datadir: "test"
rna_repo: "/home/jeszyman/repos/rna-seq"
factor_str: "run group"
#+end_src
*** [[file:workflow/int_test.smk][Integration testing]]                                                 :smk:
:PROPERTIES:
:header-args:snakemake: :tangle ./workflow/int_test.smk
:END:
**** Preamble
#+begin_src snakemake
#########1#########2#########3#########4#########5#########6#########7#########8
###                                                                          ###
###               Integration Testing Snakefile for RNA-seq                  ###
###                                                                          ###
#########1#########2#########3#########4#########5#########6#########7#########8

##################################
###   Load Required Packages   ###
##################################

import numpy as np
import os
import pandas as pd
import re

#+end_src
**** Variable naming
#+begin_src snakemake

###########################
###   Variable Naming   ###
###########################

# Names directly from configuration YAML
threads = config['threads']

# Names build from configuration parameter base
rna_script_dir = config['rna_repo'] + "/scripts"
#+end_src
**** Functions
#+begin_src snakemake
RNA_LIBS = ["lib001", "lib002", "lib003", "lib004"]
#+end_src
**** All rule
#+begin_src snakemake
rule all:
    input:
        analysis + "/{experiment}_txi.rdata",
rule dumbtest:
    output: "/tmp/test2.tsv",
    params:
        script = rna_script_dir + "/dumbtest.R"
    shell:
        """
        Rscript {params.script} \
        {output}
        """
#+end_src
- [[file:./scripts/dumbtest.R][Rscript]]
  #+begin_src R :tangle ./scripts/dumbtest.R
#!/usr/bin/env Rscript

############
###      ###
############

# For unit testing


# Command line arguements
args = commandArgs(trailingOnly = TRUE)
out= args[1]

# Load required packages
library(tidyverse)

test = data.frame(top=c(1,2,3),
                  bottom=c('a','b','c'))

test2 = as_tibble(test)

write_tsv(test2, file = out)
#+end_src
**** Benchmark aggregation
**** Includes statements
**** Bulk RNA-seq Exploratory Data Analysis Integration Testing         :smk:
:PROPERTIES:
:header-args:snakemake: :tangle ./workflow/rna_seq_eda_int.smk
:END:
***** Preamble
#+begin_src snakemake
#print("Integration testing snakefile for bulk RNA-seq\n")

# Import common packages
import pandas as pd
import re
import numpy as np

#+end_src
***** Variable naming
#+begin_src snakemake
datadir = config["datadir"]
inputs=datadir + "/inputs"
analysis = datadir + "/analysis"
salmon = analysis + "/salmon"
results = datadir + "/results"
factor_str= config["factor_str"]
rna_container = config["rna_container"]
logdir = config["datadir"] + "/logs"

rna_repo = config["rna_repo"]
rna_scriptdir = rna_repo + "/scripts"
library_tsv=inputs + "/libraries.tsv"
#+end_src
***** Functions, miscellaneous
#+begin_src snakemake
rna_libraries = pd.read_table(inputs + "/libraries.tsv")
rna_libraries["path"]= inputs + "/" + rna_libraries["basename"]

# Needs full path to work (no tilda)
readable = []
for x in rna_libraries.path:
    readable.append(os.access(x, os.R_OK))
rna_libraries['readable']=readable

rna_libraries = rna_libraries[rna_libraries.readable == True]

rna_library_indict = rna_libraries["library"].tolist()
rna_file_indict = rna_libraries["path"].tolist()
rna_lib_dict = dict(zip(rna_library_indict, rna_file_indict))

BULK_RNA_LIBS = list(rna_lib_dict.keys())

#+end_src
***** All rule
#+begin_src snakemake
rule all:
    input:
        expand(salmon + "/{library}.quant.sf", library = BULK_RNA_LIBS),
        expand(analysis + "/{experiment}_txi.rdata", experiment = "all"),
        results + "/figures/all_pca.pdf",
        analysis + "/all_eda.rdata",
#+end_src
***** Symlink inputs                                               :smk_rule:
- Snakemake
  #+begin_src snakemake
rule symlink_salmon:
    container: rna_container,
    input: lambda wildcards: rna_lib_dict[wildcards.library],
    log: logdir + "/{library}_symlink_salmon.log",
    output: salmon + "/{library}.quant.sf",
    params:
        script = rna_scriptdir + "/symlink_salmon.sh"
    shell:
        """
        {params.script} {input} {output} &> {log}
        """
#+end_src
- Shell
  #+begin_src bash :tangle ./scripts/symlink_salmon.sh
#!/usr/bin/env bash
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

variables(){
   in_salmon="${1}"
   out_sym="${2}"
}

main(){
    variables $@
    ln --force --relative --symbolic $in_salmon $out_sym
}

main "$@"

#+end_src
***** Include statements
#+begin_src snakemake
include: rna_repo + "/workflow/rna_seq_eda.smk"
#+end_src

**** Post-QC RNA-seq Differential Expression                            :smk:
:PROPERTIES:
:header-args:snakemake: :tangle ./workflow/rnaseq_de.smk
:END:
***** Preamble
#+begin_src snakemake
print("Integration testing snakefile for Post-QC RNA-seq Differential Expression\n")

# Import common packages
import pandas as pd
import re
import numpy as np

#+end_src
***** Variable naming
#+begin_src snakemake

#+end_src
***** Functions, miscellaneous
#+begin_src snakemake

#+end_src
***** All rule
#+begin_src snakemake
rule all:
    input:
        design
        tmm
        ebayes
        dds
#+end_src
***** Symlink inputs
#+begin_src snakemake
rule symlink_rnaseq_de_inputs:
    input:

#+end_src
***** Include statements
#+begin_src snakemake
#include: " <INCLUDE FILE LOCATION (VIA CONFIG PARAM)>"
#+end_src
** [[file:workflow/rna.smk][RNA-seq]]                        :smk:
:PROPERTIES:
:header-args:snakemake: :tangle ./workflows/rna.smk
:END:
*** Workflow 1
**** Reference processing
***** Make filtered GTF for whole transcriptome gene expression
https://www.biostars.org/p/106590/
#+begin_src snakemake
rule make_wtrans_filtered_gtf:
    input: f"{ref_dir}/{{build}}.gtf.gz",
    log: f"{log_dir}/{{build}}_make_wtrans_filtered_gtf.log",
    output: f"{ref_dir}/{{build}}_wtrans.gtf.gz",
    params: script = f"{rna_script_dir}/make_wtrans_filtered_gtf.sh",
    shell:
        """
        {params.script} {input} {output} > {log} 2>&1
        """
#+end_src

#+begin_src bash :tangle ./scripts/make_wtrans_filtered_gtf.sh
#!/usr/bin/env bash
in_gtf="${1}"
out_gtf="${2}"

zcat $in_gtf | awk '$0 ~ /gene_biotype "protein_coding"|gene_biotype "lncRNA"/' | gzip > $out_gtf

#+end_src

***** Make per-gtf annotation table
#+begin_src snakemake
rule make_annotation_from_gtf:
    input: f"{ref_dir}/{{build}}_wtrans.gtf.gz",
    log: f"{log_dir}/{{build}}_make_annotation_from_gtf.log",
    output: f"{ref_dir}/{{build}}_wtrans_annotation.tsv",
    params:
        bmart_data =  lambda wildcards: build_map[wildcards.build]['bmart_data'],
        script = f"{rna_script_dir}/make_annotation_from_gtf.R",
    shell:
        """
        Rscript {params.script} \
        {input} \
        {params.bmart_data} \
        {output} \
        > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_annotation_from_gtf.R
#!/usr/bin/env Rscript

#########################################
###   Make Annotate From A Gtf File   ###
#########################################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
gtf_file = args[1]
bmart_dataset = args[2]
tsv = args[3]

#  "~/cards/ref/mm10.ensGene.gtf.gz"
#bmart_dataset = "mmusculus_gene_ensembl"
#tsv =

# Load required packages, data, and functions

library(biomaRt)
library(GenomicFeatures)
library(rtracklayer)
library(tidyverse)

# Load the GTF file
gtf <- rtracklayer::import(gtf_file)

annotation = data.frame(ensembl_gene_id = gtf$gene_id) %>% distinct(ensembl_gene_id, .keep_all = TRUE)

mart = useMart("ensembl")
mart = useDataset(bmart_dataset, mart)

names = getBM(
  filters = "ensembl_gene_id",
  attributes=c("ensembl_gene_id",
               "entrezgene_id",
               "description",
               "external_gene_name",
               "gene_biotype"),
  values = annotation$ensembl_gene_id,
  mart = mart,
  uniqueRows = T)

names <- names %>% distinct(ensembl_gene_id, .keep_all = TRUE) %>% as_tibble(names)

write_tsv(names, file = tsv)
#+end_src
**** Per-library processing
***** Fastp
#+begin_src snakemake
rule pe_rna_seq_fastp:
    input:
        read1 = f"{rna_dir}/fastqs/pe/{{library}}_raw_R1.fastq.gz",
        read2 = f"{rna_dir}/fastqs/pe/{{library}}_raw_R2.fastq.gz",
    log: html = f"{log_dir}/{{library}}_pe_rna_seq_fastp.html",
    output:
        read1 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R1.fastq.gz",
        read2 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R2.fastq.gz",
        failed = f"{rna_dir}/fastqs/pe/{{library}}_failed_fastp.fastq.gz",
        unpaired1 = f"{rna_dir}/fastqs/pe/{{library}}_unpaired_R1.fastq.gz",
        unpaired2 = f"{rna_dir}/fastqs/pe/{{library}}_unpaired_R2.fastq.gz",
        json = f"{qc_dir}/{{library}}_fastp.json",
        cmd = f"{qc_dir}/{{library}}_fastp.log",
    params:
        script = f"{rna_script_dir}/pe_rna_seq_fastp.sh",
        threads = 4
    resources:
        mem_mb = 500
    shell:
        """
        {params.script} \
        {input.read1} \
        {input.read2} \
        {log.html} \
        {output.json} \
        {output.read1} \
        {output.read2} \
        {output.failed} \
        {output.unpaired1} \
        {output.unpaired2} \
        {params.threads} &> {output.cmd}
        """
#+end_src

#+begin_src bash :tangle ./scripts/pe_rna_seq_fastp.sh
#!/usr/bin/env bash
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

# Script variables

input_read1="${1}"
input_read2="${2}"
log_html="${3}"
log_json="${4}"
output_read1="${5}"
output_read2="${6}"
output_failed="${7}"
output_unpaired1="${8}"
output_unpaired2="${9}"
params_threads="${10}"

# Functions
main(){
    fastp_wrap $output_failed \
               $input_read1 \
               $input_read2 \
               $log_html \
               $log_json \
               $output_read1 \
               $output_read2 \
               $output_unpaired1 \
               $output_unpaired2 \
               $params_threads
}

fastp_wrap(){
    fastp --detect_adapter_for_pe \
          --disable_quality_filtering \
          --failed_out $output_failed \
          --in1 $input_read1 \
          --in2 $input_read2 \
          --html $log_html \
          --json $log_json \
          --out1 $output_read1 \
          --out2 $output_read2 \
          --unpaired1 $output_unpaired1 \
          --unpaired2 $output_unpaired2 \
          --thread $params_threads
    }

# Run
main "$@"

#+end_src

***** Quality control
****** Paried end FastQC
#+begin_src snakemake
rule pe_rna_seq_fastqc:
    input: f"{rna_dir}/fastqs/pe/{{library}}_{{processing}}_{{read}}.fastq.gz",
    log: f"{log_dir}/{{library}}_{{processing}}_{{read}}_rna_seq_fastqc.log",
    output: f"{qc_dir}/{{library}}_{{processing}}_{{read}}_fastqc.zip",
    params:
        out_dir = qc_dir,
        script = f"{rna_script_dir}/rna_seq_fastqc.sh",
        threads = threads,
    shell:
        """
        {params.script} \
        {input} \
        {params.out_dir} {params.threads} &> {log}
        """
#+end_src

#+begin_src bash :tangle ./scripts/rna_seq_fastqc.sh
input="${1}"
outdir="${2}"
threads="${3}"

fastqc  --outdir $outdir \
        --quiet \
        --threads $threads $input

#+end_src
***** Quantify transcripts with salmon
#+begin_src snakemake
rule pe_quant_with_salmon:
    input:
        index = f"{ref_dir}/{{build}}_salmon",
        read1 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R1.fastq.gz",
        read2 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R2.fastq.gz",
    log: f"{log_dir}/{{library}}_{{build}}_pe_quant_with_salmon.log",
    output: f"{rna_dir}/salmon/{{library}}_{{build}}/quant.sf",
    params:
        out_dir = f"{rna_dir}/salmon/{{library}}_{{build}}",
        script = f"{rna_script_dir}/pe_quant_with_salmon.sh",
        threads = 4,
    shell:
        """
        {params.script} \
        {input.index} \
        {input.read1} \
        {input.read2} \
        {params.out_dir} \
        {params.threads} > {log} 2>&1 &&
        [[ -s {output[0]} ]] || (echo "Output file is empty: {output[0]}" && exit 1)
        """
#+end_src

#+begin_src bash :tangle ./scripts/pe_quant_with_salmon.sh
#!/usr/bin/env bash

index="${1}"
read1="${2}"
read2="${3}"
out_dir="${4}"
threads="${5}"

salmon quant \
       --index $index \
       --libType A \
       --mates1 $read1 \
       --mates2 $read2 \
       --output $out_dir \
       --threads $threads \
       --validateMappings

#+end_src
**** [[id:41ccba05-da95-4f0d-b406-1ea6941e03ce][Sample group processing for a given subset of libraries by experiment]]
*** Workflow 2

Workflow 2 receives a curated list RNA-seq library IDs and associcated experimetnal design for differential gene expression workup.

**** [[id:41ccba05-da95-4f0d-b406-1ea6941e03ce][Sample group processing for a given subset of libraries by experiment]]
**** EdgeR Differential Expression Constrast
#+begin_src snakemake
rule make_edger_contrast_de:
    input:
        design = lambda wildcards: dge_map[wildcards.contrast]['design'],
        fit = lambda wildcards: dge_map[wildcards.contrast]['fit'],
    log: f"{log_dir}/{{contrast}}_make_edger_contrast_de.log",
    output: f"{rna_dir}/contrasts/{{contrast}}/{{contrast}}.tsv",
    params:
        annotation_tsv = lambda wildcards: dge_map[wildcards.contrast]['annotation_tsv'],
        cohorts_str = lambda wildcards: dge_map[wildcards.contrast]['cohorts_str'],
        script = f"{rna_script_dir}/make_edger_contrast_de.R",
    shell:
        """
        Rscript {params.script} \
        {input.design} \
        {input.fit} \
        {params.annotation_tsv} \
        "{params.cohorts_str}" \
        {output} > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_edger_contrast_de.R
#!/usr/bin/env Rscript

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
design_rds = args[1]
fit_rds = args[2]
annotation_tsv = args[3]
cohorts_str = args[4]
res_tsv = args[5]

# Load required packages, data, and functions
library(edgeR)
library(tidyverse)

design = readRDS(design_rds)
fit = readRDS(fit_rds)
annotation = read_tsv(annotation_tsv)

cohorts_vec = strsplit(cohorts_str, " ")[[1]]
contrast_string <- paste(cohorts_vec[[1]], "-", cohorts_vec[[2]])

contrast <- makeContrasts(eval(parse(text = contrast_string)), levels=design)

qlf = glmQLFTest(fit, contrast = contrast)

res =
  as.data.frame(topTags(qlf, n = Inf)) %>%
  rownames_to_column(var = "ensembl_gene_id") %>%
  as_tibble() %>%
  left_join(annotation, by = "ensembl_gene_id") %>%
  mutate(sign = sign(logFC)) %>%
  mutate(score = sign * -log10(PValue)) %>%
  mutate(rank = rank(-score, ties.method = "random"))

write_tsv(res, file = res_tsv)

#+end_src
**** Volcano plot
#+begin_src snakemake
rule rna_volcano:
    input: f"{rna_dir}/contrasts/{{contrast}}/{{contrast}}.tsv",
    log: f"{log_dir}/{{contrast}}_rna_volcano.log",
    output: f"{rna_dir}/contrasts/{{contrast}}/{{contrast}}_volcano.pdf",
    params: script = f"{rna_script_dir}/rna_volcano.R",
    shell:
        """
        Rscript {params.script} \
        {input} \
        {output} \
        > {log} 2>&1
        """
#+end_src
#+begin_src R :tangle ./scripts/rna_volcano.R
#!/usr/bin/env Rscript

################################
###   Rna-Seq Volcano Plot   ###
################################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
dge_tsv = args[1]
out_pdf = args[2]

library(tidyverse)
library(ggrepel)

dge = read_tsv(dge_tsv)

table =
  dge %>%
  mutate(FDR_filtered = ifelse(abs(logFC) > 2, FDR, NA)) %>%
  # Create a column with the rank of each row, when ordered by FDR_filtered
  mutate(rank = rank(FDR_filtered, na.last = "keep")) %>%
  # Create the 'tolabel' column based on the rank column
  mutate(label = ifelse(rank <= 10 & !is.na(rank), external_gene_name,NA)) %>%
  mutate(sig = ifelse(FDR < 0.05 & abs(logFC) > 1, "Sig", "Not sig"))

plot = ggplot(table, aes(x = logFC, y = -log10(FDR), label = label)) +
  geom_point(aes(color = sig)) +
  scale_color_discrete(guide = "none") +
  geom_vline(xintercept = c(1,-1), linetype = "dashed") +
  geom_hline(yintercept = 1.3, linetype = "dashed") +
  geom_label_repel(box.padding = 1, show.legend = F) +
  theme_minimal() +
  ylab(expression(paste(-log["10"]*" ",italic("p")))) +
  xlab("Log-fold Change") +
  ggtitle("")

ggsave(plot, file = out_pdf)
#+end_src

*** Shared
**** Sample group processing for a given subset of libraries by experiment
:PROPERTIES:
:ID:       41ccba05-da95-4f0d-b406-1ea6941e03ce
:END:
***** Create design

Make an experimental design for the list of libraries

#+begin_src snakemake
rule make_dge_design:
    input:
        libraries_full = libraries_full_rds,
    log: f"{log_dir}/{{experiment}}_make_dge_design.log",
    output: f"{rna_dir}/models/{{experiment}}/{{experiment}}_design.rds",
    params:
        formula = lambda wildcards: rna_map[wildcards.experiment]['formula'],
        libs = lambda wildcards: rna_map[wildcards.experiment]['libs'],
        script = f"{rna_script_dir}/make_dge_design.R",
    shell:
        """
        Rscript {params.script} \
        {input.libraries_full} \
        "{params.formula}" \
        "{params.libs}" \
        {output} \
        > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_dge_design.R
#!/usr/bin/env Rscript

###############################
###   Make Rna-Seq Design   ###
###############################

# ---   Command Line Arguements   --- #
# ----------------------------------- #

args = commandArgs(trailingOnly = TRUE)
libraries_full_rds = args[1]
formula = args[2]
libs_str = args[3]
design_rds = args[4]

# ---   Load   --- #
# ---------------- #

library(tidyverse)
libraries_full = readRDS(libraries_full_rds)
libs_vect = strsplit(libs_str, " ")[[1]]

# ---   Run   --- #
# --------------- #

libs =
  data.frame(library = libs_vect) %>%
  left_join(libraries_full) %>%
  mutate(across(where(is.factor), droplevels))

design = model.matrix(as.formula(formula), data = libs)

rownames(design) = libs$library

saveRDS(object = design,
        file = design_rds)
#+end_src

***** Summarize gene-level abundance with txi counts from salmon files :smk_rule:

Annotate and summarize counts for salmon files

#+begin_src snakemake

rule make_salmon_txi:
    input:
        salmon = lambda wildcards: expand(f"{rna_dir}/salmon/{{library}}_{{build}}/quant.sf",
                                          library = rna_map[wildcards.experiment]['libs'],
                                          build = rna_map[wildcards.experiment]['build']),
        gtf = lambda wildcards: f"{ref_dir}/{rna_map[wildcards.experiment]['build']}_wtrans.gtf.gz",
    log: f"{log_dir}/{{experiment}}_make_salmon_txi.log",
    output: f"{rna_dir}/models/{{experiment}}/{{experiment}}_txi.rds",
    params:
        script = rna_script_dir + "/make_salmon_txi.R",
    shell:
        """
        Rscript {params.script} \
        {input.gtf} \
        "{input.salmon}" \
        {output} > {log} 2>&1
        """

#+end_src

#+begin_src R :tangle ./scripts/make_salmon_txi.R
#!/usr/bin/env Rscript

args = commandArgs(trailingOnly = TRUE)
gtf = args[1]
salmon_str = args[2]
out_txi = args[3]

# Load libraries
library(tximport)
library(AnnotationDbi)
library(GenomicFeatures)

txdb = makeTxDbFromGFF(gtf)

# Make salmon file list
salmon_vect = unlist(strsplit(salmon_str, " "))
names(salmon_vect) = substr(gsub("^.*lib", "lib", salmon_vect), 1, 6)

# Make gene annotation
k = keys(txdb, keytype = "TXNAME")
tx2gene = AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")

# Make txi object
txi = tximport(salmon_vect, type = "salmon", tx2gene = tx2gene, ignoreTxVersion = T, ignoreAfterBar = T)

# Save txi object
saveRDS(txi, file = out_txi)
#+end_src

***** Normalize txi counts across the experimental design
#+begin_src snakemake
rule norm_txi:
    input:
        design = f"{rna_dir}/models/{{experiment}}/{{experiment}}_design.rds",
        txi = f"{rna_dir}/models/{{experiment}}/{{experiment}}_txi.rds",
    log: f"{log_dir}/{{experiment}}_norm_txi.log",
    output:
        dge = f"{rna_dir}/models/{{experiment}}/{{experiment}}_dge.rds",
        glm = f"{rna_dir}/models/{{experiment}}/{{experiment}}_fit.rds",
        cpm = f"{rna_dir}/models/{{experiment}}/{{experiment}}_cpm.tsv",
    params: script = f"{rna_script_dir}/norm_txi.R",
    shell:
        """
        Rscript {params.script} \
        {input.design} \
        {input.txi} \
        {output.dge} \
        {output.glm} \
        {output.cpm} \
        > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/norm_txi.R
#!/usr/bin/env Rscript

#######################
###   Human Edger   ###
#######################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
design_rds = args[1]
txi_rds = args[2]
dge_rds = args[3]
glm_rds = args[4]
logcpm_tsv = args[5]

# Load required packages, data, and functions
library(edgeR)
library(tidyverse)

design = readRDS(design_rds)
txi = readRDS(txi_rds)

# Make a DGE List
#  See https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html
make_dge_list = function(txi, design){
  cts <- txi$counts
  normMat <- txi$length
  # Obtaining per-observation scaling factors for length, adjusted to avoid
  # changing the magnitude of the counts.
  normMat <- normMat/exp(rowMeans(log(normMat)))
  normCts <- cts/normMat
  # Computing effective library sizes from scaled counts, to account for
  # composition biases between samples.
  eff.lib <- calcNormFactors(normCts) * colSums(normCts)
  # Combining effective library sizes with the length factors, and calculating
  # offsets for a log-link GLM.
  normMat <- sweep(normMat, 2, eff.lib, "*")
  normMat <- log(normMat)
  # Creating a DGEList object for use in edgeR.
  y <- DGEList(cts)
  keep = filterByExpr(y, design)
  y = y[keep, ]
  return(y)
}

y = make_dge_list(txi, design)

logcpm = edgeR::cpm(y, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2)

y = estimateDisp(y,design)
fit <- glmQLFit(y,design)

saveRDS(y, dge_rds)
saveRDS(fit, glm_rds)

logcpm %>% as.data.frame(.) %>% rownames_to_column(var = "ensembl") %>% as_tibble() %>% write_tsv(., file = logcpm_tsv)
#+end_src
***** PCA

Makes a logCPM-based PCA plot.

#+begin_src snakemake
rule make_cpm_pca:
    input:
        cpm = f"{rna_dir}/models/{{experiment}}/{{experiment}}_cpm.tsv",
        libraries_full = libraries_full_rds,
    log: f"{log_dir}/{{experiment}}_make_cpm_pca.log",
    output:
        f"{rna_dir}/models/{{experiment}}/{{experiment}}_pca.png",
        f"{rna_dir}/models/{{experiment}}/{{experiment}}_pca.svg",
    params:
        formula = lambda wildcards: rna_map[wildcards.experiment]['formula'],
        script = f"{rna_script_dir}/make_cpm_pca.R",
    shell:
        """
        Rscript {params.script} \
        {input.cpm} \
        "{params.formula}" \
        {input.libraries_full} \
        {output} > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_cpm_pca.R
#!/usr/bin/env Rscript
args = commandArgs(trailingOnly = TRUE)
cpm_tsv = args[1]
formula = args[2]
libraries_full_rds = args[3]
out_png = args[4]
out_svg = args[5]

factor_str = gsub("(~0 \\+)|\\s*\\*\\s*|\\s*\\+\\s*", " ", formula)
factor_str = trimws(factor_str)

factor_vec = strsplit(factor_str, " ")[[1]]
factor_vec = factor_vec[!factor_vec == "+"]

library(cowplot)
library(ggrepel)
library(tidyverse)

cpm = read_tsv(cpm_tsv)
libraries_full = readRDS(libraries_full_rds)

pca = prcomp(t(as.matrix(cpm[,-1])))

(pve_pc1=round(100*summary(pca)$importance[2,1]))

(pve_pc2=round(100*summary(pca)$importance[2,2]))

plot = as.data.frame(pca$x) %>%
  rownames_to_column(var = "library") %>%
  left_join(libraries_full, by = "library") %>%
  ggplot(., aes(x = PC1, y = PC2, color = get(factor_vec[[1]]), label = library)) +
  geom_point(size = 4) +
  geom_text_repel() +
  scale_color_discrete(name = factor_vec[[1]]) +
  xlab(paste("PC1, ", pve_pc1, "% variance explained", sep ="")) +
  ylab(paste("PC2, ", pve_pc2, "% variance explained", sep ="")) +
  coord_fixed(ratio = 1)

if (length(factor_vec) >= 2 && !is.null(factor_vec[[2]])) {
  plot = plot +
    aes(shape = get(factor_vec[[2]])) +
    scale_shape_discrete(name = factor_vec[[2]])
}

ggsave(filename = out_png, plot = plot, device = "png", width = 8, height = 6)
ggsave(filename = out_svg, plot = plot, device = "svg", width = 8, height = 6)

#+end_src
*** Development
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
**** edgeR
#+begin_src R :tangle no
#!/usr/bin/env Rscript

#######################
###   Human Edger   ###
#######################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
libraries_full_rds = args[1]
txi_rds = args[2]
design_rds = args[3]
dge_rds = args[4]
logcpm_tsv = args[5]

# Load required packages, data, and functions
library(edgeR)
library(tidyverse)
libraries_full = readRDS(libraries_full_rds)
txi = readRDS(txi_rds)

# Model design
(libs = data.frame(library = colnames(txi$counts)) %>%
  left_join(libraries_full) %>% droplevels(.))

libs$cohort=paste0(libs$strain, "_", libs$cohort)

(design <- model.matrix(~ 0 + sex + cohort, data = libs))

#(design <- model.matrix(~ 0 + cohort, data = libs))

#colnames(design) = gsub("cohort","",colnames(design))

# Make a DGE List
#  See https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html
make_dge_list = function(txi, design){
  cts <- txi$counts
  normMat <- txi$length
  # Obtaining per-observation scaling factors for length, adjusted to avoid
  # changing the magnitude of the counts.
  normMat <- normMat/exp(rowMeans(log(normMat)))
  normCts <- cts/normMat
  # Computing effective library sizes from scaled counts, to account for
  # composition biases between samples.
  eff.lib <- calcNormFactors(normCts) * colSums(normCts)
  # Combining effective library sizes with the length factors, and calculating
  # offsets for a log-link GLM.
  normMat <- sweep(normMat, 2, eff.lib, "*")
  normMat <- log(normMat)
  # Creating a DGEList object for use in edgeR.
  y <- DGEList(cts)
  keep = filterByExpr(y, design)
  y = y[keep, ]
  return(y)
}

y = make_dge_list(txi, design)


logcpm = edgeR::cpm(y, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2)

y

y = estimateDisp(y,design)

fit <- glmQLFit(y,design)


qlf <- glmQLFTest(fit,coef=2)

res = as.data.frame(topTags(qlf, n = Inf)) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

tail(res)

contrast = makeContrasts(cohortir2d, levels = design)

names(design)
colnames(design)
colnames(design) <- gsub(":", ".", colnames(design))

contrast <- makeContrasts(strainsod2.cohortir2d, levels=design)

contrast <- makeContrasts(strainsod2.cohortir2d - strainsod2, levels=design)

qlf = glmQLFTest(fit, contrast = contrast)

res %>% filter(FDR < 0.05) %>% count()
res
saveRDS(design, design_rds)
saveRDS(y, dge_rds)
logcpm %>% as.data.frame(.) %>% rownames_to_column(var = "ensembl") %>% as_tibble() %>% write_tsv(., file = logcpm_tsv)
#+end_src


**** RSeQC
- https://chat.openai.com/share/a7df0ab7-9c10-42a0-bee5-1e7c7505218d
**** All sample EDA                                                :smk_rule:
- Snakemake
  #+begin_src snakemake
rule all_rna_eda:
    container: "/home/jeszyman/sing_containers/atac.1.1.0.sif",
    input: analysis + "/{experiment}_txi.rdata",
    log: logdir + "/{experiment}_rna_eda.log",
    output:
        pca = results + "/figures/{experiment}_pca.pdf",
        rdata = analysis + "/{experiment}_eda.rdata",
    params:
        factor_str = factor_str,
        library_tsv = library_tsv,
        script = rna_scriptdir + "/all_rna_eda.R",
    shell:
        """
        Rscript {params.script} \
        {input} \
        {output.pca} \
        {output.rdata} \
        "{params.factor_str}" \
        {params.library_tsv} \
        > {log} 2>&1
        """
#+end_src
- Rscript
  #+begin_src R :tangle ./scripts/all_rna_eda.R
#!/usr/bin/env Rscript
args = commandArgs(trailingOnly = TRUE)
txi_rdata = args[1]
pca_plot_pdf = args[2]
out_rdata = args[3]
factor_str = args[4]
library_tsv = args[5]

## txi_rdata = "test/analysis/all_txi.rdata"
## library_tsv = "test/inputs/libraries.tsv"
## factor_str = "run group"
## out_rdata = "test/analysis/eda.rdata"
## pca_plot_pdf = "test/results/all_pca.pdf"

library(cowplot)

library(ggrepel)
library(tidyverse)

load(txi_rdata)

library(edgeR)

counts = txi$counts

# Obtaining per-observation scaling factors for length, adjusted to avoid
# (see https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html#edgeR)
norm_mat = txi$length
norm_mat = norm_mat/exp(rowMeans(log(norm_mat)))
norm_counts = counts/norm_mat

# Get effective library sizes from scaled counts
eff_lib = calcNormFactors(norm_counts) * colSums(norm_counts)
norm_mat = sweep(norm_mat, 2, eff_lib, "*")
norm_mat = log(norm_mat)

# Creating a DGEList object for use in edgeR.
y = DGEList(counts)
y = scaleOffset(y, norm_mat)

libraries = read_tsv(library_tsv)
factor_vec = unlist(strsplit(factor_str, " "))

formula = as.formula(paste("~ ", paste(factor_vec, collapse = "+")))
formula
design = model.matrix(formula, libraries)
design

# filtering using the design information
## design <- model.matrix(~condition, data = sampleTable)
keep <- filterByExpr(y, design)
y <- y[keep, ]

logCPM <- cpm(y, prior.count=2, log=TRUE, offset = y$offset)

pca = prcomp(t(logCPM))

make_pca_plots = function(in_pca, full_libs){
  pve_pc1=round(100*summary(in_pca)$importance[2,1])
  pve_pc2=round(100*summary(in_pca)$importance[2,2])
  pca_plot = as.data.frame(in_pca$x) %>%
    rownames_to_column(var = "library") %>%
    left_join(libraries, by = "library") %>%
    ggplot(., aes(x = PC1, y = PC2, color = get(tail(factor_vec, n= 1)), label = library)) +
    geom_point(size = 4) +
    geom_text_repel() +
    xlab(paste("PC1, ", pve_pc1, "% variance explained", sep ="")) +
    ylab(paste("PC2, ", pve_pc2, "% variance explained", sep ="")) +
    scale_color_discrete(name = paste0(tail(factor_vec, n=1))) +
    theme_cowplot() +
    theme(legend.position = "bottom")
  return(pca_plot)
}

pca_plot = make_pca_plots(pca, libraries)
# Note this resembles plotMDS(y, gene.selection = "common")

save(design, formula, logCPM, pca, pca_plot, y, file = out_rdata)

save_plot(pca_plot, file = pca_plot_pdf)
#+end_src
**** Make TxDb object from protein-coding GTF

Salmon files from GTAC are incompatible with Bioconductor TxDb packages. Here TxDbs are made from protein coding GTF files.
Note: The saveDb command makes a timeout error on writing the TxDb, thus the additional cp from tmp step (see https://support.bioconductor.org/p/9136286/).

#+begin_src snakemake
rule make_txdb_from_gtf:
    input: f"{ref_dir}/{{build}}_protein_coding.gtf",
    log: f"{log_dir}/{{build}}_make_txdb_from_gtf.log",
    output: f"{ref_dir}/{{build}}_protein.txdb",
    params: script = f"{rna_script_dir}/make_txdb_from_gtf.R",
    shell:
        """
        Rscript {params.script} {input} {wildcards.build} > {log} 2>&1
        cp /tmp/{wildcards.build}_protein.txdb {output}
        """
#+end_src

#+begin_src R :tangle ./scripts/make_txdb_from_gtf.R
args = commandArgs(trailingOnly = TRUE)
gtf = args[1]
build = args[2]

library(GenomicFeatures)

txdb = makeTxDbFromGFF(gtf)

saveDb(txdb, file = paste0("/tmp/",build,"_protein.txdb"))

#+end_src

**** Make ensembl protein-coding GTF for DE
#+begin_src snakemake
rule make_ensembl_de_gtf:
    conda: "rna",
    input:  f"{ref_dir}/{{build}}.gtf.gz",
    log:    f"{log_dir}/{{build}}_make_ensembl_de_gtf.log",
    output: f"{ref_dir}/{{build}}_protein_coding.gtf",
    shell:
        """
        zcat {input} | grep "protein_coding" > {output} 2> {log}
        """
#+end_src
**** Heatmap

MAKE THIS FOR THE LRTs!!
#+begin_src snakemake
rule dge_heatmap:
    input:
        dge = f"{rna_dir}/contrasts/{{contrast}}/{{contrast}}.tsv",
        cpm = f"{rna_dir}/models/{{model}}/{{model}}_cpm.tsv",
    log: f"{log_dir}/{{contrast}}_dge_heatmap.log",
    output: f"{rna_dir}/contrasts/{{contrast}}/{{contrast}}_heatmap.pdf",
    params: script = f"{rna_script_dir}/dge_heatmap.R",
    shell:
        """
        Rscript {params.script} \
        {input} \
        {output} \
        > {log} 2>&1
        """
#+end_src
#+begin_src R :tangle ./scripts/dge_heatmap.R
#!/usr/bin/env Rscript

###################################################
###   Heatmap Of Differential Gene Expression   ###
###################################################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
dge_tsv= args[1]
logcpm_tsv = args[2]
out_pdf = args[3]

# Load required packages, data, and functions
#dge_tsv = "~/cards/analysis/rna/contrasts/sod2_v_fvb_at_sham/sod2_v_fvb_at_sham.tsv"
#logcpm_tsv = "~/cards/analysis/rna/models/sod_kept/sod_kept_cpm.tsv"

library(ComplexHeatmap)
library(tidyverse)
library(ggsci)

dge = read_tsv(dge_tsv)

formula="~0 + cohort + sex"
factor_str = gsub("(~0 \\+)|\\s*\\*\\s*|\\s*\\+\\s*", " ", formula)
factor_str = trimws(factor_str)
factor_vec = strsplit(factor_str, " ")[[1]]


genes = dge %>% filter(rank < 2001) %>% pull(ensembl_gene_id)
logcpm = read_tsv(logcpm_tsv) %>%
  filter(ensembl %in% genes)
mat = as.matrix(logcpm[,-1])

rowz =t(apply(mat, 1, scale))
colnames(rowz) = colnames(mat)

libraries_full = readRDS(libraries_full_rds)

libs = data.frame(library = colnames(mat)) %>%
  left_join(libraries_full, by = "library") %>%
  dplyr::select(all_of(factor_vec))
ha = HeatmapAnnotation(df = libs)

pdf(out_pdf)
ht = Heatmap(rowz, top_annotation = ha,
             show_column_names = TRUE,
             column_names_rot = 45,
             column_names_side = "bottom")

draw(ht)

dev.off()
#+end_src



*** Ideas
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
** README
:PROPERTIES:
:export_file_name: ./readme.md
:export_file_options: toc:nil
:END:
*** Pipeline Directed Acyclic Graphs
*** Prerequisites for local integration testing
- See configuation file (./config/int_test.yaml) for required parameters and versioned singularity container
*** Changelog
- [2022-10-28 Fri] Stable 1.0.1 libraries_tsv naming abstracted
- [2022-10-28 Fri] Stable 1.0.0 Basic edgeR run

** Reference :ref:
- https://github.com/zhxiaokang/RASflow/blob/master/scripts/dea_genome.R
- https://bitbucket.org/cfce/viper/src/master/modules/scripts/DEseq.R
