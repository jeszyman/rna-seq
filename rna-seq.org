* RNA-seq Snakemake Pipelines :biopipe:
:PROPERTIES:
:ID:       2a6a5dac-151e-42e8-a80a-74f77ad0d4ca
:header-args: :tangle no :tangle-mode (identity #o555) :mkdirp yes :noweb yes :comments org
:END:
** Repository administration
*** Initialize a local test environment
#+begin_src bash
#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "You must source this script"
  exit 1
fi

# Unique identifier - typically the remote URL of your repo
UNIQUE_IDENTIFIER="git@github.com:jeszyman/rna-seq.git"

# Check if .git directory exists
if [ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1; then
    # Check if the remote URL matches
    CURRENT_REPO_URL=$(git config --get remote.origin.url)
    if [ "$CURRENT_REPO_URL" = "$UNIQUE_IDENTIFIER" ]; then
        echo "In the correct rna-seq repository."
        # Run your commands here
    else
        echo "Not the correct repository."
        exit 1
    fi
else
    echo "Not a Git repository."
    exit 1
fi

source /opt/miniconda3/bin/activate base

#!/bin/bash
conda env list | grep -q 'rna'
# Check if the 'rna' environment exists
if conda env list | grep -q 'rna'; then
    # Environment exists, run mamba update
    mamba env update --name rna --file ./basecamp/resources/conda/basecamp_env.yaml
else
    echo "Environment 'rna' does not exist."
fi

mamba env update --name rna --file ./basecamp/resources/conda/basecamp_env.yaml
mamba env update --name rna --file ./biotools/resources/conda/biotools_env.yaml
mamba env update --name rna --file ./config/rna_env.yaml

conda list --name rna > ./resources/rna_full_conda_env.txt

source ./biotools/lib/bioinformatics_function.sh
source ./basecamp/lib/conda_functions.sh

code.header

block.comment

set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

variables(){
    ="${1}"
}

main(){
    variables
}


bash.usage
usage(){}

[ "/" = -h ] && print_usage && exit 1

main "$@"

#+end_src

*** Emacs
#+TODO: TODO TEST(t) INPROCESS(p) DEBUG(d) REFACTOR(r) DOCUMENT(d) BLOCKED(b&) WAITING(w&) | DONE DELEGATED
*** Github continuous integration
#+begin_src bash :tangle ./.github/workflows/test.yml
name: Snakemake CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Setup Miniconda
      uses: conda-incubator/setup-miniconda@v2
      with:
        miniconda-version: "latest"
        auto-activate-base: true

    - name: Install Mamba
      run: |
        conda install -c conda-forge mamba

    - name: Create Conda Environment
      run: |
        mamba env update -f ./config/rna_env.yaml
#+end_src

>>>>>>> f1b55e3... .
*** Conda environmental YAMLs
**** RNA
#+begin_src bash :tangle ./config/rna_env.yaml
name: rna
channels:
  - conda-forge
  - bioconda

dependencies:
  - bedops
  - bedtools
  - bioconductor-GenomicRanges
  - bioconductor-orthology.eg.db
  - bioconductor-TxDb.Mmusculus.UCSC.mm10.ensGene
  - bioconductor-TxDb.Hsapiens.UCSC.hg38.knownGene
  - bioconductor-TxDb.Mmusculus.UCSC.mm10.knownGene
  - bioconductor-complexheatmap
  - bioconductor-deseq2
  - bioconductor-edger
  - bioconductor-sva
  - bioconductor-fgsea
  - bioconductor-ruvseq
  - bioconductor-rsamtools
  - bioconductor-tximport
  - bowtie2
  - fastp
  - fastqc
  - multiqc
  - pandas
  - parallel
  - r-magick
  - r-ggrepel
  - r-ggextra
  - r-ggsci
  - r-msigdbr
  - r-pheatmap
  - r-rstatix
  - r-ggpattern
  - r-tidyverse
  - r-yaml
  - rseqc
  - samtools
  - snakemake
#+end_src
*** Emacs
#+TODO: TODO TEST(t) INPROCESS(p) DEBUG(d) REFACTOR(r) DOCUMENT(d) BLOCKED(b&) WAITING(w&) | DONE DELEGATED
*** Github continuous integration
#+begin_src bash :tangle ./.github/workflows/test.yml
name: Snakemake CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Setup Miniconda
      uses: conda-incubator/setup-miniconda@v2
      with:
        miniconda-version: "latest"
        auto-activate-base: true

    - name: Install Mamba
      run: |
        conda install -c conda-forge mamba


    - name: Create Conda Environment
      run: |
        mamba env update -f ./config/rna_env.yaml

#+end_src
- file:test/inputs/libraries.tsv
  | library | basename            | participant | run  | group |
  |---------+---------------------+-------------+------+-------|
  | lib001  | ctrl.quant.sf       | subj001     | seq1 | ctrl  |
  | lib002  | ctrl2.quant.sf      | subj002     | seq2 | ctrl  |
  | lib003  | normal.quant.sf     | subj003     | seq1 | ctrl  |
  | lib004  | exp1.quant.sf       | subj004     | seq2 | exp   |
  | lib005  | exp2.quant.sf       | subj005     | seq1 | exp   |
  | lib006  | expsample3.quant.sf | subj006     | seq2 | exp   |
*** Snakemake configuration YAML
#+begin_src bash :tangle ./config/int_test.yaml
experiment_id: inttest_human
txdb: "TxDb.Mmusculus.UCSC.mm10.ensGene",
threads: 4
rna_container: "/home/jeszyman/sing_containers/rna.1.2.0.sif"
datadir: "test"
rna_repo: "/home/jeszyman/repos/rna-seq"
factor_str: "run group"

#+end_src

*** DONE [[id:1a8d792b-9621-42a8-80c9-399b6065630a][Bioinformatics pipeline initial build]]
CLOSED: [2022-10-26 Wed 13:48]
** README
:PROPERTIES:
:export_file_name: ./readme.md
:export_file_options: toc:nil
:END:
*** Pipeline Directed Acyclic Graphs
*** Prerequisites for local integration testing
- See configuation file (./config/int_test.yaml) for required parameters and versioned singularity container
*** Changelog
** Development :dev:
:PROPERTIES:
:header-args: :tangle no
:ID:       9dfffdc1-8c5c-4e29-8498-cbd440270c46
:END:
*** Generate heatmap at results step
*** TEST Likelihood ratio test
#+begin_src snakemake
rule make_edger_lrt:
    input:
        design = lambda wildcards: lrt_map[wildcards.contrast]['design'],
        fit = lambda wildcards: lrt_map[wildcards.contrast]['fit'],
    log: f"{log_dir}/{{contrast}}_make_edger_lrt.log",
    output: f"{rna_dir}/contrasts/lrt_{{contrast}}/lrt_{{contrast}}.tsv",
    params: script = f"{rna_script_dir}/make_edger_lrt.R",
    shell:
        """
        Rscript {params.script} {input} {output} > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_edger_lrt.R
#!/usr/bin/env Rscript
#!/usr/bin/env Rscript

########################################################
###   Make Edger Contrast By Likelihood Ratio Test   ###
########################################################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
design_rds = args[1]
fit_rds = args[2]
res_tsv = args[3]

# Load required packages, data, and functions
design = readRDS(design_rds)
fit = readRDS(fit_rds)

lrt = glmLRT(fit, coef = 2)


res =
  as.data.frame(topTags(lrt, n = Inf)) %>%
  rownames_to_column(var = "ensembl_gene_id") %>%
  as_tibble() %>%
  left_join(annotation, by = "ensembl_gene_id") %>%
  mutate(sign = sign(logFC)) %>%
  mutate(score = sign * -log10(PValue)) %>%
  mutate(rank = rank(-score, ties.method = "random"))

write_tsv(res, file = res_tsv)

#+end_src

*** standardize naming across outputs
example of contrast-specific naming

make_res = function(contrast, fit, contrast_name){
  res = glmQLFTest(fit, contrast = contrast)
  res = data.frame(topTags(res, n = Inf)) %>%
    rownames_to_column(var = "ensembl") %>% as_tibble() %>%
    rename("logfc" = "logFC",
           "logcpm" = "logCPM",
           "pval" = "PValue",
           "qval" = "FDR") %>%
    select(!F) %>%
    rename_with(~paste0(contrast_name, "_", .), -ensembl)
  return(res)
}

*** DESeq2 alternative DGE
*** STAR

 STAR --runThreadN 16 --runMode genomeGenerate --genomeDir
 /scratch/jeszyman/star/star_mouse/mm10/ --genomeFastaFiles
 /scratch/jeszyman/star/star_mouse/mm10/mm10.fa
 --limitGenomeGenerateRAM 60000000000 --sjdbGTFfile /scratch/jeszyman/star/star_mouse/mm10/mm10_gencode.gtf --genomeSAsparseD 2 --genomeChrBinNbits 14

 and same w/ G38: (these are both gunzipped- adding that param)

 STAR --runThreadN 16 --runMode genomeGenerate --genomeDir /scratch/jeszyman/star/star_mouse/GRCm38/
 --genomeFastaFiles/scratch/jeszyman/star/star_mouse/GRCm38.fa.gz
 --limitGenomeGenerateRAM 60000000000 --sjdbGTFfile
 /scratch/jeszyman/star/star_mouse/GRCm38.gtf.gz --genomeSAsparseD 2
 --genomeChrBinNbits 14 --readFilesCommand zcat


**** RSeQC - depends on star bams
- https://chat.openai.com/share/a7df0ab7-9c10-42a0-bee5-1e7c7505218d
*** Kegg ssGSEA heatmap
#+begin_src R

gsea = bind_rows(gsea_list, .id = "gsea") %>%
  mutate(species = ifelse(grepl("ms", gsea), "mouse", "human")) %>%
  mutate(cohort = gsub("_.*$","",gsea)) %>%
  mutate(pathway_set = gsub("^.*_","",gsea)) %>%
  dplyr::select(species, cohort, pathway_set, pathway, padj, pval, everything()) %>%
  dplyr::select(!c(gsea,leadingEdge))
gsea

write_tsv(gsea, "/tmp/cardradbio_gsea.tsv")


ms_24h_rank



library(edgeR)


library(readxl)
library(clusterProfiler)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(biomaRt)

#
#########1#########2#########3#########4#########5#########6#########7#########8
# GSEA


#KEGG GSEA
# geneList is fold-change as numeric vector named with entrez ID

ms_kegg = msigdbr("mouse", category = "C2", subcategory = "CP:KEGG")
ms_reactome = msigdbr("mouse", category = "C2", subcategory = "CP:REACTOME")
ms_hallmark = msigdbr("mouse", category = "H")
ms_go_bp = msigdbr("mouse", category = "C5", subcategory = "GO:BP")
hs_kegg = msigdbr("human", category = "C2", subcategory = "CP:KEGG")
hs_reactome= msigdbr("human", category = "C2", subcategory = "CP:REACTOME")
hs_hallmark = msigdbr("human", category = "H")
hs_go_bp = msigdbr("human", category = "C5", subcategory = "GO:BP")

msig_list = list(ms_kegg, ms_reactome, ms_hallmark, ms_go_bp, hs_kegg, hs_reactome, hs_hallmark, hs_go_bp)
names(msig_list) = c("ms_kegg", "ms_reactome", "ms_hallmark", "ms_go_bp", "hs_kegg", "hs_reactome", "hs_hallmark", "hs_go_bp")

make_fgsea_paths = function(msig){
  pathways = split(as.character(msig$entrez_gene), msig$gs_name)
}

fgsea_paths = lapply(msig_list, make_fgsea_paths)

fgsea_paths_ms = fgsea_paths[1:4]
fgsea_paths_hs = fgsea_paths[5:8]

run_fgsea = function(pathways, stats){
  gsea = fgsea(pathways = pathways,
               stats = stats,
               scoreType = "pos")
}

ms_24h_gsea = lapply(fgsea_paths_ms, run_fgsea, ms_24h_rank)
names(ms_24h_gsea) = paste0("24h_", names(ms_24h_gsea))

ms_2w_gsea = lapply(fgsea_paths_ms, run_fgsea, ms_2w_rank)
names(ms_2w_gsea) = paste0("2w_", names(ms_2w_gsea))

ms_6w_gsea = lapply(fgsea_paths_ms, run_fgsea, ms_6w_rank)
names(ms_6w_gsea) = paste0("6w_", names(ms_6w_gsea))

hs_2w_gsea = lapply(fgsea_paths_hs, run_fgsea, hs_2w_rank)
names(hs_2w_gsea) = paste0("2w_", names(hs_2w_gsea))

gsea_list = c(ms_24h_gsea, ms_2w_gsea, ms_6w_gsea, hs_2w_gsea)

gsea = bind_rows(gsea_list, .id = "gsea") %>%
  mutate(species = ifelse(grepl("ms", gsea), "mouse", "human")) %>%
  mutate(cohort = gsub("_.*$","",gsea)) %>%
  mutate(pathway_set = gsub("^.*_","",gsea)) %>%
  dplyr::select(species, cohort, pathway_set, pathway, padj, pval, everything()) %>%
  dplyr::select(!c(gsea,leadingEdge))
gsea

write_tsv(gsea, "/tmp/cardradbio_gsea.tsv")


names(gsea)

%>%
  mutate(pathways = gsub("^.*_","",gsea))


test
search_kegg_organism('mmu')

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk, n = 100)

kk


#data(geneList, package="DOSE")
#gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk)
dotplot(kk)
library("pathview")
hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))


head(km)

library("pathview")

library("pathview")

hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110 <- pathview(gene.data  = geneList3,
                     pathway.id = "mmu00190",
                     species    = "mmu",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110

gene <- names(geneList)[abs(geneList) > 2]

mkk <- enrichMKEGG(gene = gene,
                   organism = 'mmu',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1)
head(mkk)



kk2 <- gseKEGG(gene     = gene,
               organism     = 'mouse',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)
cnetplot(kk)
gene = as.character(genes$entrezgene_id)

test = groupGO(gene = gene,
               OrgDb = org.Mm.eg.db,
               ont = "MF",
               level = 3,
               readable = TRUE)

ego <- enrichGO(gene          = gene,
                universe      = names(geneList),
                OrgDb         = org.Hs.eg.db,
                ont           = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)
head(ego)
summary(test)
class(test)
plot(test)

test

library(clusterProfiler)
data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

# Entrez gene ID
head(gene)

test
plot(test)

library(org.Hs.eg.db)

ggo <- groupGO(gene     = gene,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo)

#########1#########2#########3#########4#########5#########6#########7#########8

# KEGG

library(clusterProfiler)
data(geneList)
de = names(geneList)[1:100]
de
xx = enrichMKEGG(de, organism='hsa', minGSSize = 1)
head(summary(xx))
yy = gseMKEGG(geneList)
head(summary(yy))

search_kegg_organism("ece", by = 'kegg_code')

search_kegg_organism("mus")

data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'hsa',
                 pvalueCutoff = 0.05)
head(kk)

kk2 <- gseKEGG(geneList     = geneList,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)

mouse =


load("~/card/tmp/bulk_rna.rdata")
libraries = read_tsv("~/card/libraries.tsv")

head(edgr_filt_bulk_rna_dge)

head(de)





#+end_src
*** [#Y] metaboloic pathways rna-seq


#+begin_src R :tangle ./scripts/agg_gsea.R
# For unit testing
#gsea_file_path = "/mnt/ris/jschwarz/Active/cardiac-radiobiology/analysis/wtrans"
#gsea_file_pattern = "_gsea"
#gsea_xlsx = "/tmp/gsea.xlsx"

# Command line arguments
args = commandArgs(trailingOnly = TRUE)
gsea_file_path = args[1]
gsea_file_pattern = args[2]
gsea_xlsx = args[3]

library(tidyverse)
library(openxlsx)

# Aggregate gsea results to single table
gsea_files = list.files(gsea_file_path, gsea_file_pattern, full.names = TRUE)

names(gsea_files) = list.files(gsea_file_path, gsea_file_pattern, full.names = FALSE)

gsea_dfs = lapply(gsea_files, read_tsv)

gsea = bind_rows(gsea_dfs, .id = "gsea") %>%
  mutate(species = gsub("_.*$", "", gsea)) %>%
  mutate(cohort = gsub(".*_(.*)_gsea.*", "\\1", gsea)) %>%
  mutate(pathway_set = gsub("_.*$","", pathway)) %>%
  select(species, cohort, pathway_set, everything()) %>%
  select(!gsea)
gsea

write.xlsx(gsea, gsea_xlsx)

#+end_src

#+begin_src bash
Rscript scripts/agg_gsea.R \
    "/mnt/ris/jschwarz/Active/cardiac-radiobiology/analysis/wtrans" \
    "_gsea" \
    "/mnt/ris/jschwarz/Active/cardiac-radiobiology/results/metabolism_gsea/metabolism_gsea.xlsx"

rclone copy --update /mnt/ris/jschwarz/Active/cardiac-radiobiology/results/metabolism_gsea remote:shared/cardiac-radiobiology/results/metabolism_gsea

#+end_src


- [ ] explore ds pathways
- [ ] reorder by time
- [ ] simplify complex
- [ ] human + mouse figs


- pathview across time
  #+begin_src R
# For unit testing



library(boxr)
library(edgeR)
library(fgsea)
library(msigdbr)
library(readxl)



library(clusterProfiler)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(biomaRt)

# Get libraries for mouse bulk tissue whole-transcriptome RNA-seq
box_auth()
box_excel_wrap = function(id,sheet){
  out_tib = box_read_excel(id, sheet = sheet) %>%
    tibble()
}
manual_inputs_excel = "1051257953480"
sheet = manual_inputs_excel
libraries = box_excel_wrap(sheet, "libraries")
datadir = "/mnt/ris/jschwarz/Active/cardiac-radiobiology"

#

ms_24h_gsea = lapply(fgsea_paths_ms, run_fgsea, ms_24h_rank)
names(ms_24h_gsea) = paste0("24h_", names(ms_24h_gsea))

ms_2w_gsea = lapply(fgsea_paths_ms, run_fgsea, ms_2w_rank)
names(ms_2w_gsea) = paste0("2w_", names(ms_2w_gsea))

ms_6w_gsea = lapply(fgsea_paths_ms, run_fgsea, ms_6w_rank)
names(ms_6w_gsea) = paste0("6w_", names(ms_6w_gsea))

hs_2w_gsea = lapply(fgsea_paths_hs, run_fgsea, hs_2w_rank)
names(hs_2w_gsea) = paste0("2w_", names(hs_2w_gsea))

gsea_list = c(ms_24h_gsea, ms_2w_gsea, ms_6w_gsea, hs_2w_gsea)

gsea = bind_rows(gsea_list, .id = "gsea") %>%
  mutate(species = ifelse(grepl("ms", gsea), "mouse", "human")) %>%
  mutate(cohort = gsub("_.*$","",gsea)) %>%
  mutate(pathway_set = gsub("^.*_","",gsea)) %>%
  dplyr::select(species, cohort, pathway_set, pathway, padj, pval, everything()) %>%
  dplyr::select(!c(gsea,leadingEdge))
gsea

write_tsv(gsea, "/tmp/cardradbio_gsea.tsv")


names(gsea)

%>%
  mutate(pathways = gsub("^.*_","",gsea))


test
search_kegg_organism('mmu')

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk, n = 100)

kk


#data(geneList, package="DOSE")
#gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk)
dotplot(kk)
library("pathview")
hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))


head(km)

library("pathview")

library("pathview")

hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110 <- pathview(gene.data  = geneList3,
                     pathway.id = "mmu00190",
                     species    = "mmu",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110

gene <- names(geneList)[abs(geneList) > 2]

mkk <- enrichMKEGG(gene = gene,
                   organism = 'mmu',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1)
head(mkk)



kk2 <- gseKEGG(gene     = gene,
               organism     = 'mouse',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)
cnetplot(kk)
gene = as.character(genes$entrezgene_id)

test = groupGO(gene = gene,
               OrgDb = org.Mm.eg.db,
               ont = "MF",
               level = 3,
               readable = TRUE)

ego <- enrichGO(gene          = gene,
                universe      = names(geneList),
                OrgDb         = org.Hs.eg.db,
                ont           = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)
head(ego)
summary(test)
class(test)
plot(test)

test

library(clusterProfiler)
data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

# Entrez gene ID
head(gene)

test
plot(test)

library(org.Hs.eg.db)

ggo <- groupGO(gene     = gene,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo)

#########1#########2#########3#########4#########5#########6#########7#########8

# KEGG

library(clusterProfiler)
data(geneList)
de = names(geneList)[1:100]
de
xx = enrichMKEGG(de, organism='hsa', minGSSize = 1)
head(summary(xx))
yy = gseMKEGG(geneList)
head(summary(yy))

search_kegg_organism("ece", by = 'kegg_code')

search_kegg_organism("mus")

data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'hsa',
                 pvalueCutoff = 0.05)
head(kk)

kk2 <- gseKEGG(geneList     = geneList,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)

mouse =


load("~/card/tmp/bulk_rna.rdata")
libraries = read_tsv("~/card/libraries.tsv")

head(edgr_filt_bulk_rna_dge)

head(de)



#+end_src


- ssgsea heatmap
  #+begin_src R
# https://www.genome.jp/brite/htext=br08901&query=Human%20Diseases&option=-s
kegg_disease = c("PATHWAYS IN CANCER","TRANSCRIPTIONAL MISREGULATION IN CANCER","MICRORNAS IN CANCER","PROTEOGLYCANS IN CANCER","CHEMICAL CARCINOGENESIS - DNA ADDUCTS","CHEMICAL CARCINOGENESIS - RECEPTOR ACTIVATION","CHEMICAL CARCINOGENESIS - REACTIVE OXYGEN SPECIES","VIRAL CARCINOGENESIS","CENTRAL CARBON METABOLISM IN CANCER","CHOLINE METABOLISM IN CANCER","PD-L1 EXPRESSION AND PD-1 CHECKPOINT PATHWAY IN CANCER","COLORECTAL CANCER","PANCREATIC CANCER","HEPATOCELLULAR CARCINOMA","GASTRIC CANCER","GLIOMA","THYROID CANCER","ACUTE MYELOID LEUKEMIA","CHRONIC MYELOID LEUKEMIA","BASAL CELL CARCINOMA","MELANOMA","RENAL CELL CARCINOMA","BLADDER CANCER","PROSTATE CANCER","ENDOMETRIAL CANCER","BREAST CANCER","SMALL CELL LUNG CANCER","NON-SMALL CELL LUNG CANCER","HUMAN T-CELL LEUKEMIA VIRUS 1 INFECTION","HUMAN IMMUNODEFICIENCY VIRUS 1 INFECTION","HEPATITIS B","HEPATITIS C","CORONAVIRUS DISEASE - COVID-19","INFLUENZA A","MEASLES","HERPES SIMPLEX VIRUS 1 INFECTION","HUMAN CYTOMEGALOVIRUS INFECTION","KAPOSI SARCOMA-ASSOCIATED HERPESVIRUS INFECTION","EPSTEIN-BARR VIRUS INFECTION","HUMAN PAPILLOMAVIRUS INFECTION","VIBRIO CHOLERAE INFECTION","EPITHELIAL CELL SIGNALING IN HELICOBACTER PYLORI INFECTION","PATHOGENIC ESCHERICHIA COLI INFECTION","SALMONELLA INFECTION","SHIGELLOSIS","YERSINIA INFECTION","PERTUSSIS","LEGIONELLOSIS","STAPHYLOCOCCUS AUREUS INFECTION","TUBERCULOSIS","BACTERIAL INVASION OF EPITHELIAL CELLS","AMOEBIASIS","MALARIA","TOXOPLASMOSIS","LEISHMANIA_INFECTION","CHAGAS DISEASE","AFRICAN TRYPANOSOMIASIS","ASTHMA","SYSTEMIC LUPUS ERYTHEMATOSUS","RHEUMATOID ARTHRITIS","AUTOIMMUNE THYROID DISEASE","INFLAMMATORY BOWEL DISEASE","ALLOGRAFT REJECTION","GRAFT-VERSUS-HOST DISEASE","PRIMARY IMMUNODEFICIENCY","ALZHEIMERS DISEASE","PARKINSONS DISEASE","AMYOTROPHIC LATERAL SCLEROSIS","HUNTINGTONS DISEASE","SPINOCEREBELLAR ATAXIA","PRION DISEASE","PATHWAYS OF NEURODEGENERATION - MULTIPLE DISEASES","COCAINE ADDICTION","AMPHETAMINE ADDICTION","MORPHINE ADDICTION","NICOTINE ADDICTION","ALCOHOLISM","LIPID AND ATHEROSCLEROSIS","FLUID SHEAR STRESS AND ATHEROSCLEROSIS","HYPERTROPHIC CARDIOMYOPATHY","ARRHYTHMOGENIC RIGHT VENTRICULAR CARDIOMYOPATHY","DILATED CARDIOMYOPATHY","DIABETIC CARDIOMYOPATHY","VIRAL MYOCARDITIS","TYPE II DIABETES MELLITUS","TYPE I DIABETES MELLITUS","MATURITY ONSET DIABETES OF THE YOUNG","ALCOHOLIC LIVER DISEASE","NON-ALCOHOLIC FATTY LIVER DISEASE","INSULIN RESISTANCE","AGE-RAGE SIGNALING PATHWAY IN DIABETIC COMPLICATIONS","CUSHING SYNDROME","BETA-LACTAM RESISTANCE","VANCOMYCIN RESISTANCE","CATIONIC ANTIMICROBIAL PEPTIDE (CAMP) RESISTANCE","EGFR TYROSINE KINASE INHIBITOR RESISTANCE","PLATINUM DRUG RESISTANCE","ANTIFOLATE RESISTANCE","ENDOCRINE RESISTANCE")
kegg_disease=paste0("KEGG_", kegg_disease)
kegg_disease = gsub(" ","_", kegg_disease)
kegg_disease = gsub("-","_", kegg_disease)

# For unit testing
ssgsea_path = "/mnt/ris/jschwarz/Active/cardiac-radiobiology/analysis/wtrans"
ssgsea_pattern = "ssgsea_"
inputs_rdata =  "/mnt/ris/jschwarz/Active/cardiac-radiobiology/data-model/inputs.rda"

# Load necessary libraries
library(ComplexHeatmap)
library(ggsci)
library(scales)
library(tidyverse)

load(inputs_rdata)

ssgsea_tsvs = list.files(ssgsea_path, ssgsea_pattern, full.names = TRUE)
names(ssgsea_tsvs) = list.files(ssgsea_path, ssgsea_pattern)

ssgsea_tsvs

ssgsea_tibs = lapply(ssgsea_tsvs, read_tsv)

list2env(ssgsea_tibs, .GlobalEnv)

#########1#########2#########3#########4#########5#########6#########7#########8



gsea_sigs = list.files(ssgsea_path, "_gsea", full.names = TRUE)
names(gsea_sigs) = list.files(ssgsea_path, "_gsea", full.names = FALSE)
gsea_sigs = lapply(gsea_sigs, read_tsv)

list2env(gsea_sigs, .GlobalEnv)

human_kegg = `human_ssgsea_human_C2_CP:KEGG.tsv`
mouse_kegg = `mouse_ssgsea_mouse_C2_CP:KEGG.tsv`

keep_paths_human = human_kegg_sig %>% filter(padj < 0.1) %>%
  filter(!pathway %in% kegg_disease) %>% pull(pathway)
keep_paths

kegg_sig = rbind(`mouse_ir24h-sham_gsea_mouse_C2_CP:KEGG.tsv`,
                 `mouse_ir2w-sham_gsea_mouse_C2_CP:KEGG.tsv`,
                 `mouse_ir6w-sham_gsea_mouse_C2_CP:KEGG.tsv`,
                 `human_ir2w-sham_gsea_human_C2_CP:KEGG.tsv`)%>% as_tibble() %>%
  filter(padj < 0.05) %>% filter(!pathway %in% kegg_disease) %>% pull(pathway) %>% (unique)
kegg_sig

wtrans_libs =
  index %>% left_join(libraries, by = "library") %>% left_join(specimens, by = "specimen") %>% left_join(subjects, by = "subject") %>%
  mutate(cohort = factor(cohort, levels = c("sham", "ir24h", "ir48h", "ir2w", "ir6w")))

make_lib_order = function(ssgsea,libraries){
  lib_order = data.frame(library = colnames(ssgsea[,-1])) %>% left_join(libraries, by = "library") %>% arrange(cohort, library) %>% pull(library)
  return(lib_order)
}

mouse_lib_order = make_lib_order(mouse_kegg,wtrans_libs)
human_lib_order = make_lib_order(human_kegg,wtrans_libs)

make_mat = function(ssgsea, lib_order, kept_paths){
  pathway = ssgsea$pathway
  mat = as.matrix(ssgsea[,-1])
  mat = mat[,lib_order]
  rownames(mat) = pathway
  mat = mat[keep_paths,]
  rownames(mat) = gsub("KEGG_","",rownames(mat))
  return(mat)
}

mouse_kegg_mat = make_mat(mouse_kegg, mouse_lib_order, kegg_sig)
human_kegg_mat = make_mat(human_kegg, human_lib_order, kegg_sig)

color = data.frame(cohort = c("sham", "ir24h", "ir2w", "ir6w"),
                   color = pal_nejm()(4))


make_col_anno = function(mat,libraries){
  res_libs = data.frame(library = colnames(mat)) %>% left_join(libraries, by = "library") %>% select(library, cohort)
  ha = HeatmapAnnotation(Cohort = res_libs$cohort,
                         col = list(Cohort = c("sham" = "#BC3C29FF",
                                               "ir24h" = "#0072B5FF",
                                               "ir2w" = "#E18727FF",
                                               "ir6w" = "#20854EFF")))
  return(ha)
}

mouse_ha = make_col_anno(mouse_kegg_mat, wtrans_libs)
human_ha = make_col_anno(human_kegg_mat, wtrans_libs)

ms_kegg_heat =
  Heatmap(mouse_kegg_mat,
          top_annotation = mouse_ha,
          cluster_columns = FALSE,
          column_title = "Mouse")

ms_kegg_heat

hs_kegg_heat =
  Heatmap(human_kegg_mat,
          top_annotation = human_ha,
          cluster_columns = FALSE,
          column_title = "Human")

draw(hs_kegg_heat, heatmap_legend_side = "bottom", annotation_legend_side = "bottom", merge_legend = T)

kegg = ms_kegg_heat + hs_kegg_heat

pdf("/mnt/ris/jschwarz/Active/cardiac-radiobiology/results/metabolism_gsea/kegg.pdf", width = 20, height = 10)
draw(hallmark, column_title = "KEGG")
dev.off()


#########1#########2#########3#########4#########5#########6#########7#########8
# Hallmark
human_h = `human_ssgsea_human_H.tsv`
mouse_h = `mouse_ssgsea_mouse_H.tsv`

keep_paths = rbind(`mouse_ir24h-sham_gsea_mouse_H.tsv`,
                   `mouse_ir2w-sham_gsea_mouse_H.tsv`,
                   `mouse_ir6w-sham_gsea_mouse_H.tsv`,
                   `human_ir2w-sham_gsea_human_H.tsv`) %>%
  filter(padj < 0.05) %>% pull(pathway) %>% unique()


make_lib_order = function(ssgsea,libraries){
  lib_order = data.frame(library = colnames(ssgsea[,-1])) %>% left_join(libraries, by = "library") %>% arrange(cohort, library) %>% pull(library)
  return(lib_order)
}

mouse_lib_order = make_lib_order(mouse_h,wtrans_libs)
human_lib_order = make_lib_order(human_h,wtrans_libs)

make_mat = function(ssgsea, lib_order, kept_paths){
  pathway = ssgsea$pathway
  mat = as.matrix(ssgsea[,-1])
  mat = mat[,lib_order]
  rownames(mat) = pathway
  mat = mat[keep_paths,]
  rownames(mat) = gsub("HALLMARK_","",gsub("KEGG_","",rownames(mat)))
  return(mat)
}

mouse_h_mat = make_mat(mouse_h, mouse_lib_order, keep_paths)
human_h_mat = make_mat(human_h, human_lib_order, keep_paths)

color = data.frame(cohort = c("sham", "ir24h", "ir2w", "ir6w"),
                   color = pal_nejm()(4))


make_col_anno = function(mat,libraries){
  res_libs = data.frame(library = colnames(mat)) %>% left_join(libraries, by = "library") %>% select(library, cohort)
  ha = HeatmapAnnotation(Cohort = res_libs$cohort,
                         col = list(Cohort = c("sham" = "#BC3C29FF",
                                               "ir24h" = "#0072B5FF",
                                               "ir2w" = "#E18727FF",
                                               "ir6w" = "#20854EFF")))
  return(ha)
}

mouse_ha = make_col_anno(mouse_h_mat, wtrans_libs)
human_ha = make_col_anno(human_h_mat, wtrans_libs)

ms_h_heat =
  Heatmap(mouse_h_mat,
          top_annotation = mouse_ha,
          cluster_columns = F,
          column_title = "Mouse")
ms_h_heat

hs_h_heat =
Heatmap(human_h_mat,
        top_annotation = human_ha,
        cluster_columns = F,
        column_title = "Human")
hs_h_heat

hallmark = ms_h_heat + hs_h_heat

pdf("/mnt/ris/jschwarz/Active/cardiac-radiobiology/results/metabolism_gsea/hallmark.pdf", width = 20, height = 10)
draw(hallmark, column_title = "Hallmark")
dev.off()



#########1#########2#########3#########4#########5#########6#########7#########8
# Reactome

human_r = `human_ssgsea_human_C2_CP:REACTOME.tsv`
mouse_r = `mouse_ssgsea_mouse_C2_CP:REACTOME.tsv`

keep_paths = rbind(`mouse_ir24h-sham_gsea_mouse_C2_CP:REACTOME.tsv`,
                   `mouse_ir2w-sham_gsea_mouse_C2_CP:REACTOME.tsv`,
                   `mouse_ir6w-sham_gsea_mouse_C2_CP:REACTOME.tsv`, `human_ir2w-sham_gsea_human_C2_CP:REACTOME.tsv`) %>%
  filter(padj < 0.05) %>% pull(pathway) %>% unique()

mouse_lib_order = make_lib_order(mouse_r,wtrans_libs)
human_lib_order = make_lib_order(human_r,wtrans_libs)

make_mat = function(ssgsea, lib_order, kept_paths){
  pathway = ssgsea$pathway
  mat = as.matrix(ssgsea[,-1])
  mat = mat[,lib_order]
  rownames(mat) = pathway
  mat = mat[keep_paths,]
  rownames(mat) = gsub("REACTOME_","",gsub("HALLMARK_","",gsub("KEGG_","",rownames(mat))))
  return(mat)
}

mouse_r_mat = make_mat(mouse_r, mouse_lib_order, keep_paths)
human_r_mat = make_mat(human_r, human_lib_order, keep_paths)

color = data.frame(cohort = c("sham", "ir24h", "ir2w", "ir6w"),
                   color = pal_nejm()(4))


make_col_anno = function(mat,libraries){
  res_libs = data.frame(library = colnames(mat)) %>% left_join(libraries, by = "library") %>% select(library, cohort)
  ha = HeatmapAnnotation(Cohort = res_libs$cohort,
                         col = list(Cohort = c("sham" = "#BC3C29FF",
                                               "ir24h" = "#0072B5FF",
                                               "ir2w" = "#E18727FF",
                                               "ir6w" = "#20854EFF")))
  return(ha)
}

mouse_ha = make_col_anno(mouse_r_mat, wtrans_libs)
human_ha = make_col_anno(human_r_mat, wtrans_libs)

ms_r_heat =
  Heatmap(mouse_r_mat,
          top_annotation = mouse_ha,
          cluster_columns = F,
          column_title = "Mouse")
ms_r_heat

hs_r_heat =
Heatmap(human_r_mat,
        top_annotation = human_ha,
        cluster_columns = F,
        column_title = "Human")
hs_r_heat

reactome = ms_r_heat + hs_r_heat

pdf("/mnt/ris/jschwarz/Active/cardiac-radiobiology/results/metabolism_gsea/reactome.pdf", width = 20, height = 10)
draw(reactome, column_title = "Reactome")
dev.off()
#+end_src
- ideas
  - sort kegg modules by topic https://www.genome.jp/kegg-bin/show_organism?menu_type=pathway_maps&org=mmu
  - highlighed pathway expresssio nin pathview https://bioconductor.org/packages/devel/bioc/vignettes/pathview/inst/doc/pathview.pdf
  - degpatterns expression time course
    - https://github.com/lpantano/DEGreport/issues/28
    - https://hbctraining.github.io/DGE_workshop_salmon_online/lessons/08a_DGE_LRT_results.html
    - https://www.bioconductor.org/packages/release/bioc/vignettes/DEGreport/inst/doc/DEGreport.html#detect-patterns-of-expression
    - maybe expand biomaRt identifiers
    - expand leading edge analysis
  - time course with
    - https://bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/geseca-tutorial.html#analysis-of-time-course-data
  - gvsa https://bioconductor.org/packages/release/bioc/html/GSVA.html
  - spearmans across species and timept
- reference
  - [[https://mail.google.com/mail/u/0/#inbox/FMfcgzGrbRPkVNFlTKdSvrbqnTBDRVKp][email with request]]
- make human de
  #+begin_src R

# Make tx object from salmon counts
##
## Make tx2gene table
txdb = TxDb.Mmusculus.UCSC.mm10.ensGene
k = keys(txdb, keytype = "TXNAME")
tx2gene = AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")
##
## Make salmon file vector
salmon = mouse_rna$salmon
names(salmon)=mouse_rna$library

txi = tximport(salmon, type = "salmon", tx2gene = tx2gene)

save(txi, file="~/card/tmp/txi.RData")

# Process txi for edgeR
# https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html

cts <- txi$counts
normMat <- txi$length

# Obtaining per-observation scaling factors for length, adjusted to avoid
# changing the magnitude of the counts.
normMat <- normMat/exp(rowMeans(log(normMat)))
normCts <- cts/normMat

# Computing effective library sizes from scaled counts, to account for
# composition biases between samples.
eff.lib <- calcNormFactors(normCts) * colSums(normCts)

# Combining effective library sizes with the length factors, and calculating
# offsets for a log-link GLM.
normMat <- sweep(normMat, 2, eff.lib, "*")
normMat <- log(normMat)

# Creating a DGEList object for use in edgeR.
y <- DGEList(cts)
y <- scaleOffset(y, normMat)

#########1#########2#########3#########4#########5#########6#########7#########8

# Setup design matrix
groups = mouse_rna %>% pull(cohort)
groups = fct_relevel(groups, "sham", "ir24h", "ir2w", "ir6w")
y$samples$group = groups
design <- model.matrix(~0 + groups, data=y$samples)
colnames(design) = levels(groups)


# Filter DGEList by design
keep <- filterByExpr(y, design)
y <- y[keep, ]

y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust=TRUE)

results <- glmQLFTest(fit, contrast=makeContrasts(ir24h-sham, levels=design))

pre_de = topTags(results, n = "Inf")$table %>% rownames_to_column(var = "ensembl_gene_id") %>% as_tibble()

entrez <- getBM(
  filters="ensembl_gene_id",
  attributes=c("ensembl_gene_id", "entrezgene_id"),
  values=pre_de$ensembl_gene_id,
  mart=mart)

de = pre_de %>% left_join(entrez, by = "ensembl_gene_id")

de
sigs = test %>% filter(FDR < 0.05 & abs(logFC) > 1) %>% pull(ensembl_gene)
upsigs = test %>% dplyr::filter(FDR < 0.05 & logFC > 1) %>% pull(ensembl_gene)

upsigs

mart <- useDataset("mmusculus_gene_ensembl", useMart("ensembl"))


gene = as.character(genes$entrezgene_id)

search_kegg_organism('mmu')

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk, n = 100)

kk


#data(geneList, package="DOSE")
#gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk)
dotplot(kk)
library("pathview")
hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

#########1#########2#########3#########4#########5#########6#########7#########8
#KEGG GSEA
# geneList is fold-change as numeric vector named with entrez ID


data(geneList, package="DOSE")
class(geneList)
head(geneList)

kk2 <- gseKEGG(geneList     = geneList,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)

-log10(de$PValue)

de = de %>% mutate(pscore = -log10(PValue))

geneList2 = de %>% filter(!is.na(entrezgene_id)) %>% mutate(rank = rank(pscore, ties.method="random")) %>% arrange(-rank)

geneList3 = geneList2$rank
names(geneList3) = geneList2$entrezgene_id

arrange(pscore) %>% pull(pscore)
names(geneList2) = de %>% filter(!is.na(entrezgene_id)) %>% arrange(pscore) %>% pull(entrezgene_id)

de[[type]]
head(geneList2)
class(geneList2)


km <- gseKEGG(geneList     = geneList3,
               organism     = 'mmu',
              nPerm        = 1000,
              minGSSize    = 120,
              pvalueCutoff = 0.05,
              verbose      = FALSE)

head(km)

library("pathview")

library("pathview")

hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110 <- pathview(gene.data  = geneList3,
                     pathway.id = "mmu00190",
                     species    = "mmu",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110

gene <- names(geneList)[abs(geneList) > 2]

mkk <- enrichMKEGG(gene = gene,
                   organism = 'mmu',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1)
head(mkk)



kk2 <- gseKEGG(gene     = gene,
               organism     = 'mouse',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)
cnetplot(kk)
gene = as.character(genes$entrezgene_id)

test = groupGO(gene = gene,
               OrgDb = org.Mm.eg.db,
               ont = "MF",
               level = 3,
               readable = TRUE)

ego <- enrichGO(gene          = gene,
                universe      = names(geneList),
                OrgDb         = org.Hs.eg.db,
                ont           = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)
head(ego)
summary(test)
class(test)
plot(test)

test

library(clusterProfiler)
data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

# Entrez gene ID
head(gene)

test
plot(test)

library(org.Hs.eg.db)

ggo <- groupGO(gene     = gene,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo)

#########1#########2#########3#########4#########5#########6#########7#########8

# KEGG

library(clusterProfiler)
data(geneList)
de = names(geneList)[1:100]
de
xx = enrichMKEGG(de, organism='hsa', minGSSize = 1)
head(summary(xx))
yy = gseMKEGG(geneList)
head(summary(yy))

search_kegg_organism("ece", by = 'kegg_code')

search_kegg_organism("mus")

data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'hsa',
                 pvalueCutoff = 0.05)
head(kk)

kk2 <- gseKEGG(geneList     = geneList,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)

mouse =


load("~/card/tmp/bulk_rna.rdata")
libraries = read_tsv("~/card/libraries.tsv")

head(edgr_filt_bulk_rna_dge)

head(de)
#+end_src
- co-expression
  #+begin_src R
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("ReactomePA")
#########1#########2#########3#########4#########5#########6#########7#########8
library(boxr)
library(edgeR)
library(readxl)
library(tidyverse)
library(TxDb.Mmusculus.UCSC.mm10.ensGene)
library(tximport)
library(clusterProfiler)
library(org.Mm.eg.db)
library(biomaRt)
library(ReactomePA)

mart <- useDataset("mmusculus_gene_ensembl", useMart("ensembl"))

entrez <- getBM(
  filters="ensembl_gene_id",
  attributes=c("ensembl_gene_id", "entrezgene_id"),
  values=rownames(fit$counts),
  mart=mart)

contrasts_mouse=c("ir24h-sham")

make_edger_results = function(contrast){
  results = glmQLFTest(fit, contrast = makeContrasts(contrast, levels=design))
}


results = glmQLFTest(fit, contrast = makeContrasts(ir24h-sham, levels=design))

de = topTags(results, n = "Inf")$table %>%
                               rownames_to_column(var = "ensembl_gene_id") %>%
                               as_tibble() %>%
                               left_join(entrez, by = "ensembl_gene_id") %>%
                               filter(!is.na(entrezgene_id)) %>%
                               group_by(entrezgene_id) %>% slice_min(FDR) %>% ungroup() %>%
                               mutate(pscore = -log10(PValue)) %>%
                               mutate(rank = rank(pscore, ties.method="random")) %>%
                               arrange(-rank)
de

geneList = de$rank
names(geneList) = de$entrezgene_id

km <- gseKEGG(geneList     = geneList,
               organism     = 'mmu',
              nPerm        = 1000,
              minGSSize    = 120,
              pvalueCutoff = 0.05,
              verbose      = FALSE)

head(summary(km))


library(ReactomePA)
y <- gsePathway(geneList,
                pvalueCutoff = 0.2,
                pAdjustMethod = "BH",
                verbose = FALSE)
head(y)

de = de %>% mutate(pscore = -log10(PValue))

geneList2 = de %>% filter(!is.na(entrezgene_id))

geneList3 = geneList2$rank
names(geneList3) = geneList2$entrezgene_id

arrange(pscore) %>% pull(pscore)
names(geneList2) = de %>% filter(!is.na(entrezgene_id)) %>% arrange(pscore) %>% pull(entrezgene_id)



de
sigs = test %>% filter(FDR < 0.05 & abs(logFC) > 1) %>% pull(ensembl_gene)
upsigs = test %>% dplyr::filter(FDR < 0.05 & logFC > 1) %>% pull(ensembl_gene)

upsigs




de[[type]]
head(geneList2)
class(geneList2)



# Get libraries for mouse bulk tissue whole-transcriptome RNA-seq
box_auth()
box_excel_wrap = function(id,sheet){
  out_tib = box_read_excel(id, sheet = sheet) %>%
    tibble()
}
manual_inputs_excel = "1051257953480"
sheet = manual_inputs_excel
libraries = box_excel_wrap(sheet, "libraries")
datadir = "/mnt/ris/jschwarz/Active/cardiac-radiobiology"

mouse_rna =
  libraries %>%
  filter(isolation == "wtrans_rna") %>% filter(species == "mouse") %>%
  # Add path for salmon files
  mutate(lib_str = sub("\\.([^\\.]*)$","",gsub("\\_.*$", "",r1_basename))) %>%
  mutate(salmon = paste0(datadir, "/inputs/", run, "/", lib_str, "/", lib_str, ".quant.sf")) %>%
  mutate(readable = file.exists(salmon)) %>%
  filter(readable == T)
mouse_rna

# Make tx object from salmon counts
##
## Make tx2gene table
txdb = TxDb.Mmusculus.UCSC.mm10.ensGene
k = keys(txdb, keytype = "TXNAME")
tx2gene = AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")
##
## Make salmon file vector
salmon = mouse_rna$salmon
names(salmon)=mouse_rna$library

txi = tximport(salmon, type = "salmon", tx2gene = tx2gene)

save(txi, file="~/card/tmp/txi.RData")

# Process txi for edgeR
# https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html

cts <- txi$counts
normMat <- txi$length

# Obtaining per-observation scaling factors for length, adjusted to avoid
# changing the magnitude of the counts.
normMat <- normMat/exp(rowMeans(log(normMat)))
normCts <- cts/normMat

# Computing effective library sizes from scaled counts, to account for
# composition biases between samples.
eff.lib <- calcNormFactors(normCts) * colSums(normCts)

# Combining effective library sizes with the length factors, and calculating
# offsets for a log-link GLM.
normMat <- sweep(normMat, 2, eff.lib, "*")
normMat <- log(normMat)

# Creating a DGEList object for use in edgeR.
y <- DGEList(cts)
y <- scaleOffset(y, normMat)

#########1#########2#########3#########4#########5#########6#########7#########8

# Setup design matrix
groups = mouse_rna %>% pull(cohort)
groups = fct_relevel(groups, "sham", "ir24h", "ir2w", "ir6w")
y$samples$group = groups
design <- model.matrix(~0 + groups, data=y$samples)
colnames(design) = levels(groups)


# Filter DGEList by design
keep <- filterByExpr(y, design)
y <- y[keep, ]

y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust=TRUE)





gene = as.character(genes$entrezgene_id)

search_kegg_organism('mmu')

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk, n = 100)

kk


#data(geneList, package="DOSE")
#gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'mouse',
                 pvalueCutoff = 0.05)
head(kk)
dotplot(kk)
library("pathview")
hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

#########1#########2#########3#########4#########5#########6#########7#########8
#KEGG GSEA
# geneList is fold-change as numeric vector named with entrez ID


data(geneList, package="DOSE")
class(geneList)
head(geneList)

kk2 <- gseKEGG(geneList     = geneList,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)

-log10(de$PValue)

head(km)

library("pathview")

library("pathview")

hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa04110",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110 <- pathview(gene.data  = geneList3,
                     pathway.id = "mmu00190",
                     species    = "mmu",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110

gene <- names(geneList)[abs(geneList) > 2]

mkk <- enrichMKEGG(gene = gene,
                   organism = 'mmu',
                   pvalueCutoff = 1,
                   qvalueCutoff = 1)
head(mkk)



kk2 <- gseKEGG(gene     = gene,
               organism     = 'mouse',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)
cnetplot(kk)
gene = as.character(genes$entrezgene_id)

test = groupGO(gene = gene,
               OrgDb = org.Mm.eg.db,
               ont = "MF",
               level = 3,
               readable = TRUE)

ego <- enrichGO(gene          = gene,
                universe      = names(geneList),
                OrgDb         = org.Hs.eg.db,
                ont           = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)
head(ego)
summary(test)
class(test)
plot(test)

test

library(clusterProfiler)
data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

# Entrez gene ID
head(gene)

test
plot(test)

library(org.Hs.eg.db)

ggo <- groupGO(gene     = gene,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo)

#########1#########2#########3#########4#########5#########6#########7#########8

# KEGG

library(clusterProfiler)
data(geneList)
de = names(geneList)[1:100]
de
xx = enrichMKEGG(de, organism='hsa', minGSSize = 1)
head(summary(xx))
yy = gseMKEGG(geneList)
head(summary(yy))

search_kegg_organism("ece", by = 'kegg_code')

search_kegg_organism("mus")

data(geneList, package="DOSE")
gene <- names(geneList)[abs(geneList) > 2]

kk <- enrichKEGG(gene         = gene,
                 organism     = 'hsa',
                 pvalueCutoff = 0.05)
head(kk)

kk2 <- gseKEGG(geneList     = geneList,
               organism     = 'hsa',
               minGSSize    = 120,
               pvalueCutoff = 0.05,
               verbose      = FALSE)
head(kk2)

mouse =


load("~/card/tmp/bulk_rna.rdata")
libraries = read_tsv("~/card/libraries.tsv")

head(edgr_filt_bulk_rna_dge)

head(de)
#+end_src

#+begin_src R
ssgsea
save_tsv(as.data.frame()
class(ssgsea)
head(ssgsea)
#########1#########2#########3#########4#########5#########6#########7#########8
head(mouse_logcpm)
head(human_logcpm)

# MSigDB Gene List Sets
make_gene_list = function(msigdb_df){
  msigdb_list = split(x = msigdb_df$ensembl_gene, f = msigdb_df$gs_name)
}

ms_hallmark_lists = make_gene_list(ms_hallmark)
ms_kegg_lists = make_gene_list(ms_kegg)
ms_reactome_lists = make_gene_list(ms_reactome)


testgsva = gsva(mouse_logcpm, msigdbr_list)

ms_kegg_gsva = gsva(mouse_logcpm, ms_kegg_list)

ms_reactome_gsva = gsva(mouse_logcpm, ms_reactome_list)

cohort = data.frame(library = colnames(testgsva)) %>% left_join(libraries, by = "library") %>% pull(cohort)
cohort
library(ggsci)

color = data.frame(cohort = c("sham", "ir24h", "ir2w", "ir6w"),
                   color = pal_nejm()(4))

library(scales)
show_col(color$color)

cola = as.data.frame(cohort) %>% left_join(color) %>% pull(color)


ha = HeatmapAnnotation(bar = cohort,
                       col = list(bar = c("sham" = "#BC3C29FF",
                                          "ir24h" = "#0072B5FF",
                                          "ir2w" = "#E18727FF",
                                          "ir6w" = "#20854EFF")))


Heatmap(testgsva,
        row_labels = gsub("HALLMARK_","",rownames(testgsva)),
        top_annotation = ha)

Heatmap(ms_kegg_gsva,         top_annotation = ha)

# After clustering demonstrated, enforce time order

Heatmap(testgsva,
        row_labels = pathways,
        top_annotation = ha)

Heatmap(ms_kegg_gsva,
        top_annotation = ha)

Heatmap(ms_reactome_gsva,
        top_annotation = ha)


#########1#########2#########3#########4#########5#########6#########7#########8
# first attempt at species merge
mouse_cpm = edgeR::cpm(mouse_dge, normalized.lib.sizes = TRUE)

head(mouse_cpm)

libraries

mouse_sham_libs = libraries %>% filter(isolation == "wtrans_rna" & species == "mouse" & cohort == "sham") %>% pull(library)

mouse_sham_libs

mouse_sham_cpm = mouse_cpm[,mouse_sham_libs]

mouse_median_sham = apply(mouse_sham_cpm, 1, median)

mouse_dif = sweep(mouse_cpm, 2, mouse_median_sham, "-")
mouse_scale = scale(mouse_dif, center=T, scale = T)

test
mart <- useDataset("mmusculus_gene_ensembl", useMart("ensembl"))

test=head(rownames(mouse_logcpm))

entrez <- getBM(
  filters="ensembl_gene_id",
  attributes=c("ensembl_gene_id", "entrezgene_id"),
  values = rownames(mouse_logcpm),
  mart=mart)

head(entrez)

entrez = entrez %>% filter(! entrezgene_id == "")

class(entrez)
test=mouse_logcpm[entrez$ensembl_gene_id,]

rownames(test) = entrez$entrezgene_id

names(ms_hallmark)
test2=(ms_hallmark$entrez_gene)

msigdbr_list = split(x = test2$entrez_gene, f = test2$gs_name)

ms_hallmark = msigdbr("mouse", category = "H")
 msigdbr_df = msigdbr("mouse", category = "H")

msigdbr_list = split(x = msigdbr_df$ensembl_gene, f = msigdbr_df$gs_name)

testgsva = gsva(mouse_logcpm, msigdbr_list)

testgsva

testscale = gsva(mouse_scale, msigdbr_list, kcdf="Poisson")
# if delta cpm gives comparable resutls, then could merge human

#+end_src



** [[file:workflows/rna.smk][RNA-seq]]                        :smk:
:PROPERTIES:
:header-args:snakemake: :tangle ./workflows/rna.smk
:END:
*** Writeup
:PROPERTIES:
:ID:       5626df9f-63f0-4ea3-8736-80bda68ece56
:CUSTOM_ID:      5626df9f-63f0-4ea3-8736-80bda68ece56
:END:

Bulk RNA-seq reads were adapter-trimmed using fastp [[cite:&chen2018b]] and read quality was assessed using FastQC [[cite:&andrews2010]]. Transcript abundance was quantified using salmon [[cite:&patro2017]] and transcript abundance was aggregated to gene-level counts using tximport [[cite:&soneson2016tximport]]. Counts for all protein coding and long non-coding RNA genes were aggregated. Gene abundance counts normalized in EdgeR [[cite:&chen2008]]. Count-level quality control included principal component analysis. Batch correction was performed in ComBat-seq [[cite:&zhang2020combat]]. Differential expression was also determined in EdgeR using glmQLFTest for individual cohort contrasts. Gene set enrichment analysis was performed in the fgsea R package [[cite:&korotkevich2016fgsea]] with pathway sets from the msigdbr package [[cite:&dolgalev2022msigdbr]].

*** Workflow 1: Initial processing
**** Preamble
#+begin_src snakemake

######################################
###   RNA-seq Initial Processing   ###
######################################

#+end_src

**** Reference processing
***** Make filtered Ensembl GTF for whole transcriptome gene expression

Makes a GTF with only protien_coding and lincRNA biotypes from an Ensembl GTF

***** Make filtered GTF for whole transcriptome gene expression
- https://www.biostars.org/p/106590/
#+begin_src snakemake
rule make_wtrans_filtered_gtf:
    input: f"{ref_dir}/{{build}}.gtf.gz",
    log: f"{log_dir}/{{build}}_make_wtrans_filtered_gtf.log",
    output: f"{ref_dir}/{{build}}_wtrans.gtf.gz",
    params: script = f"{rna_script_dir}/make_wtrans_filtered_gtf.sh",
    shell:
        """
        {params.script} {input} {output} > {log} 2>&1
        """
#+end_src

#+begin_src bash :tangle ./scripts/make_wtrans_filtered_gtf.sh
#!/usr/bin/env bash
in_gtf="${1}"
out_gtf="${2}"

zcat $in_gtf | awk '$0 ~ /gene_biotype "protein_coding"|gene_biotype "lncRNA"/' | gzip > $out_gtf

#+end_src

***** Make per-gtf annotation table
#+begin_src snakemake
rule make_annotation_from_gtf:
    input: f"{ref_dir}/{{build}}_wtrans.gtf.gz",
    log: f"{log_dir}/{{build}}_make_annotation_from_gtf.log",
    output: f"{ref_dir}/{{build}}_wtrans_annotation.tsv",
    params:
        bmart_data =  lambda wildcards: build_map[wildcards.build]['bmart_data'],
        script = f"{rna_script_dir}/make_annotation_from_gtf.R",
    shell:
        """
        Rscript {params.script} \
        {input} \
        {params.bmart_data} \
        {output} \
        > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_annotation_from_gtf.R
#!/usr/bin/env Rscript

#########################################
###   Make Annotate From A Gtf File   ###
#########################################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
gtf_file = args[1]
bmart_dataset = args[2]
tsv = args[3]

#  "~/cards/ref/mm10.ensGene.gtf.gz"
#bmart_dataset = "mmusculus_gene_ensembl"
#tsv =

# Load required packages, data, and functions

library(biomaRt)
library(GenomicFeatures)
library(rtracklayer)
library(tidyverse)

# Load the GTF file
gtf <- rtracklayer::import(gtf_file)

annotation = data.frame(ensembl_gene_id = gtf$gene_id) %>% distinct(ensembl_gene_id, .keep_all = TRUE)

mart = useMart("ensembl")
mart = useDataset(bmart_dataset, mart)

names = getBM(
  filters = "ensembl_gene_id",
  attributes=c("ensembl_gene_id",
               "entrezgene_id",
               "description",
               "external_gene_name",
               "gene_biotype"),
  values = annotation$ensembl_gene_id,
  mart = mart,
  uniqueRows = T)

names =
  names %>% group_by(ensembl_gene_id) %>% slice_head(n = 1)

write_tsv(names, file = tsv)
#+end_src

**** Per-library processing
***** Fastp

#+begin_src snakemake
rule pe_rna_seq_fastp:
    input:
        read1 = f"{rna_dir}/fastqs/pe/{{library}}_raw_R1.fastq.gz",
        read2 = f"{rna_dir}/fastqs/pe/{{library}}_raw_R2.fastq.gz",
    log: html = f"{log_dir}/{{library}}_pe_rna_seq_fastp.html",
    output:
        read1 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R1.fastq.gz",
        read2 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R2.fastq.gz",
        failed = f"{rna_dir}/fastqs/pe/{{library}}_failed_fastp.fastq.gz",
        unpaired1 = f"{rna_dir}/fastqs/pe/{{library}}_unpaired_R1.fastq.gz",
        unpaired2 = f"{rna_dir}/fastqs/pe/{{library}}_unpaired_R2.fastq.gz",
        json = f"{rna_qc_dir}/{{library}}_fastp.json",
        cmd = f"{rna_qc_dir}/{{library}}_fastp.log",
    params:
        script = f"{rna_script_dir}/pe_rna_seq_fastp.sh",
        threads = 4
    resources:
        mem_mb = 500
    shell:
        """
        {params.script} \
        {input.read1} \
        {input.read2} \
        {log.html} \
        {output.json} \
        {output.read1} \
        {output.read2} \
        {output.failed} \
        {output.unpaired1} \
        {output.unpaired2} \
        {params.threads} &> {output.cmd}
        """
#+end_src

#+begin_src bash :tangle ./scripts/pe_rna_seq_fastp.sh
#!/usr/bin/env bash
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

# Script variables

input_read1="${1}"
input_read2="${2}"
log_html="${3}"
log_json="${4}"
output_read1="${5}"
output_read2="${6}"
output_failed="${7}"
output_unpaired1="${8}"
output_unpaired2="${9}"
params_threads="${10}"

# Functions
main(){
    fastp_wrap $output_failed \
               $input_read1 \
               $input_read2 \
               $log_html \
               $log_json \
               $output_read1 \
               $output_read2 \
               $output_unpaired1 \
               $output_unpaired2 \
               $params_threads
}

fastp_wrap(){
    fastp --detect_adapter_for_pe \
          --disable_quality_filtering \
          --failed_out $output_failed \
          --in1 $input_read1 \
          --in2 $input_read2 \
          --html $log_html \
          --json $log_json \
          --out1 $output_read1 \
          --out2 $output_read2 \
          --unpaired1 $output_unpaired1 \
          --unpaired2 $output_unpaired2 \
          --thread $params_threads
    }

# Run
main "$@"

#+end_src

***** Read-level Quality control with FastQC

#+begin_src snakemake
rule pe_rna_seq_fastqc:
    input: f"{rna_dir}/fastqs/pe/{{library}}_{{processing}}_{{read}}.fastq.gz",
    log: f"{log_dir}/{{library}}_{{processing}}_{{read}}_rna_seq_fastqc.log",
    output: f"{rna_qc_dir}/{{library}}_{{processing}}_{{read}}_fastqc.zip",
    params:
        out_dir = rna_qc_dir,
        script = f"{rna_script_dir}/rna_seq_fastqc.sh",
        threads = threads,
    shell:
        """
        {params.script} \
        {input} \
        {params.out_dir} {params.threads} &> {log}
        """
#+end_src

#+begin_src bash :tangle ./scripts/rna_seq_fastqc.sh
input="${1}"
outdir="${2}"
threads="${3}"

fastqc  --outdir $outdir \
        --quiet \
        --threads $threads $input

#+end_src

***** Quantify transcripts with salmon
#+begin_src snakemake
rule pe_quant_with_salmon:
    input:
        index = f"{ref_dir}/{{build}}_salmon",
        read1 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R1.fastq.gz",
        read2 = f"{rna_dir}/fastqs/pe/{{library}}_proc_R2.fastq.gz",
    log: f"{log_dir}/{{library}}_{{build}}_pe_quant_with_salmon.log",
    output: f"{rna_dir}/salmon/{{library}}_{{build}}/quant.sf",
    params:
        out_dir = f"{rna_dir}/salmon/{{library}}_{{build}}",
        script = f"{rna_script_dir}/pe_quant_with_salmon.sh",
        threads = 4,
    shell:
        """
        {params.script} \
        {input.index} \
        {input.read1} \
        {input.read2} \
        {params.out_dir} \
        {params.threads} > {log} 2>&1 &&
        [[ -s {output[0]} ]] || (echo "Output file is empty: {output[0]}" && exit 1)
        """
#+end_src

#+begin_src bash :tangle ./scripts/pe_quant_with_salmon.sh
#!/usr/bin/env bash

index="${1}"
read1="${2}"
read2="${3}"
out_dir="${4}"
threads="${5}"

salmon quant \
       --index $index \
       --libType A \
       --mates1 $read1 \
       --mates2 $read2 \
       --output $out_dir \
       --threads $threads \
       --validateMappings

#+end_src
*** Workflow 2: Per-experiment
**** Unadjusted
***** Create design

Make an experimental design for the list of libraries.

#+begin_src snakemake
rule make_dge_design:
    input:
        libraries_full = libraries_full_rds,
    log: f"{log_dir}/{{experiment}}_make_dge_design.log",
    output: f"{rna_dir}/models/unadjusted/{{experiment}}/design.rds",
    params:
        formula = lambda wildcards: rna_map[wildcards.experiment]['formula'],
        libs = lambda wildcards: rna_map[wildcards.experiment]['libs'],
        script = f"{rna_script_dir}/make_dge_design.R",
    shell:
        """
        Rscript {params.script} \
        {input.libraries_full} \
        "{params.formula}" \
        "{params.libs}" \
        {output} \
        > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_dge_design.R
#!/usr/bin/env Rscript

###############################
###   Make Rna-Seq Design   ###
###############################

# ---   Command Line Arguements   --- #
# ----------------------------------- #

args = commandArgs(trailingOnly = TRUE)
libraries_full_rds = args[1]
formula = args[2]
libs_str = args[3]
design_rds = args[4]

# ---   Load   --- #
# ---------------- #

library(tidyverse)
libraries_full = readRDS(libraries_full_rds)
libs_vect = strsplit(libs_str, " ")[[1]]

# ---   Run   --- #
# --------------- #

libs =
  data.frame(library = libs_vect) %>%
  left_join(libraries_full) %>%
  mutate(across(where(is.factor), droplevels))

design = model.matrix(as.formula(formula), data = libs)

rownames(design) = libs$library


saveRDS(object = design,
        file = design_rds)
#+end_src
***** Summarize gene-level abundance with txi counts from salmon files :smk_rule:

Annotate and summarize counts for salmon files

#+begin_src snakemake

rule make_salmon_txi:
    input:
        salmon = lambda wildcards: expand(f"{rna_dir}/salmon/{{library}}_{{build}}/quant.sf",
                                          library = rna_map[wildcards.experiment]['libs'],
                                          build = rna_map[wildcards.experiment]['build']),
        gtf = lambda wildcards: f"{ref_dir}/{rna_map[wildcards.experiment]['build']}_wtrans.gtf.gz",
    log: f"{log_dir}/{{experiment}}_make_salmon_txi.log",
    output: f"{rna_dir}/models/unadjusted/{{experiment}}/txi.rds",
    params:
        script = rna_script_dir + "/make_salmon_txi.R",
    shell:
        """
        Rscript {params.script} \
        {input.gtf} \
        "{input.salmon}" \
        {output} > {log} 2>&1
        """

#+end_src

#+begin_src R :tangle ./scripts/make_salmon_txi.R
#!/usr/bin/env Rscript

args = commandArgs(trailingOnly = TRUE)
gtf = args[1]
salmon_str = args[2]
out_txi = args[3]

# Load libraries
library(tximport)
library(AnnotationDbi)
library(GenomicFeatures)

txdb = makeTxDbFromGFF(gtf)

# Make salmon file list
salmon_vect = unlist(strsplit(salmon_str, " "))
names(salmon_vect) = substr(gsub("^.*lib", "lib", salmon_vect), 1, 6)

# Make gene annotation
k = keys(txdb, keytype = "TXNAME")
tx2gene = AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")

# Make txi object
txi = tximport(salmon_vect, type = "salmon", tx2gene = tx2gene, ignoreTxVersion = T, ignoreAfterBar = T)

# Save txi object
saveRDS(txi, file = out_txi)
#+end_src

***** Normalize txi counts across the experimental design for use in edgeR
#+begin_src snakemake
rule norm_txi_edger:
    input:
        design = f"{rna_dir}/models/{{experiment}}/design.rds",
        txi = f"{rna_dir}/models/{{experiment}}/txi.rds",
    log: f"{log_dir}/{{experiment}}_norm_txi_edger.log",
    output:
        dge = f"{rna_dir}/models/unadjusted/{{experiment}}/edger_dge.rds",
        glm = f"{rna_dir}/models/unadjusted/{{experiment}}/edger_fit.rds",
        cpm = f"{rna_dir}/models/unadjusted/{{experiment}}/edger_cpm.tsv",
    params: script = f"{rna_script_dir}/norm_txi_edger.R",
    shell:
        """
        Rscript {params.script} \
        {input.design} \
        {input.txi} \
        {output.dge} \
        {output.glm} \
        {output.cpm} \
        > {log} 2>&1
        """
#+end_src
#+begin_src R :tangle ./scripts/norm_txi_edger.R
#!/usr/bin/env Rscript

#######################
###   Human Edger   ###
#######################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
design_rds = args[1]
txi_rds = args[2]
dge_rds = args[3]
glm_rds = args[4]
logcpm_tsv = args[5]

# Load required packages, data, and functions
library(edgeR)
library(tidyverse)

design = readRDS(design_rds)
txi = readRDS(txi_rds)

# Make a DGE List
#  See https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html
make_dge_list = function(txi, design){
  cts <- txi$counts
  normMat <- txi$length
  # Obtaining per-observation scaling factors for length, adjusted to avoid
  # changing the magnitude of the counts.
  normMat <- normMat/exp(rowMeans(log(normMat)))
  normCts <- cts/normMat
  # Computing effective library sizes from scaled counts, to account for
  # composition biases between samples.
  eff.lib <- calcNormFactors(normCts) * colSums(normCts)
  # Combining effective library sizes with the length factors, and calculating
  # offsets for a log-link GLM.
  normMat <- sweep(normMat, 2, eff.lib, "*")
  normMat <- log(normMat)
  # Creating a DGEList object for use in edgeR.
  y <- DGEList(cts)
  keep = filterByExpr(y, design)
  y = y[keep, ]
  return(y)
}

y = make_dge_list(txi, design)

logcpm = edgeR::cpm(y, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2)

y = estimateDisp(y,design)
fit <- glmQLFit(y,design)

saveRDS(y, dge_rds)
saveRDS(fit, glm_rds)

logcpm %>% as.data.frame(.) %>% rownames_to_column(var = "ensembl") %>% as_tibble() %>% write_tsv(., file = logcpm_tsv)
#+end_src
***** PCA

Makes a logCPM-based PCA plot.

#+begin_src snakemake
rule make_cpm_pca:
    input:
        cpm = f"{rna_dir}/models/unadjusted/{{experiment}}/edger_cpm.tsv",
        libraries_full = libraries_full_rds,
    log: f"{log_dir}/{{experiment}}_make_cpm_pca.log",
    output:
        f"{rna_dir}/models/unadjusted/{{experiment}}/pca.png",
        f"{rna_dir}/models/unadjusted/{{experiment}}/pca.svg",
    params:
        formula = lambda wildcards: rna_map[wildcards.experiment]['formula'],
        script = f"{rna_script_dir}/make_cpm_pca.R",
    shell:
        """
        Rscript {params.script} \
        {input.cpm} \
        "{params.formula}" \
        {input.libraries_full} \
        {output} > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_cpm_pca.R
#!/usr/bin/env Rscript
args = commandArgs(trailingOnly = TRUE)
cpm_tsv = args[1]
formula = args[2]
libraries_full_rds = args[3]
out_png = args[4]
out_svg = args[5]

factor_str = gsub("(~0 \\+)|\\s*\\*\\s*|\\s*\\+\\s*", " ", formula)
factor_str = trimws(factor_str)

factor_vec = strsplit(factor_str, " ")[[1]]
factor_vec <- factor_vec[!grepl("~|:|\\+", factor_vec)]

library(cowplot)
library(ggrepel)
library(tidyverse)

cpm = read_tsv(cpm_tsv)
libraries_full = readRDS(libraries_full_rds)

pca = prcomp(t(as.matrix(cpm[,-1])))

(pve_pc1=round(100*summary(pca)$importance[2,1]))

(pve_pc2=round(100*summary(pca)$importance[2,2]))

plot = as.data.frame(pca$x) %>%
  rownames_to_column(var = "library") %>%
  left_join(libraries_full, by = "library") %>%
  ggplot(., aes(x = PC1, y = PC2, color = get(factor_vec[[1]]), label = library)) +
  geom_point(size = 4) +
  geom_text_repel() +
  scale_color_discrete(name = factor_vec[[1]]) +
  xlab(paste("PC1, ", pve_pc1, "% variance explained", sep ="")) +
  ylab(paste("PC2, ", pve_pc2, "% variance explained", sep ="")) +
  coord_fixed(ratio = 1)

if (length(factor_vec) >= 2 && !is.null(factor_vec[[2]])) {
  plot = plot +
    aes(shape = get(factor_vec[[2]])) +
    scale_shape_discrete(name = factor_vec[[2]])
}

ggsave(filename = out_png, plot = plot, device = "png", width = 8, height = 6)
ggsave(filename = out_svg, plot = plot, device = "svg", width = 8, height = 6)

#+end_src
**** Batch correction with ComBat-seq
#+begin_src snakemake
rule make_rna_batch_corrections:
    input:
        design = f"{rna_dir}/models/unadjusted/{{experiment}}/design.rds",
        libs = libraries_full_rds,
        txi = f"{rna_dir}/models/unadjusted/{{experiment}}/txi.rds",
    output:
        design = f"{rna_dir}/models/combat/{{experiment}}/design.rds",
        dge = f"{rna_dir}/models/combat/{{experiment}}/edger_dge.rds",
        glm = f"{rna_dir}/models/combat/{{experiment}}/edger_fit.rds",
        pca = f"{rna_dir}/models/combat/{{experiment}}/pca.pdf",
    params:
        batch_var = lambda wildcards: rna_map[wildcards.experiment]['batch_var'],
        covars = lambda wildcards: rna_map[wildcards.experiment]['covars'],
        script = f"{rna_script_dir}/make_rna_batch_corrections.R",
    shell:
        """
	cp {input.design} {output.design}
	Rscript {params.script} \
	--batch_var {params.batch_var} \
	--covars {params.covars} \
	--design_rds {output.design} \
	--dge_rds {output.dge} \
	--glm_rds {output.glm} \
	--libraries_full_rds {input.libs} \
	--pdf {output.pca} \
	--txi_rds {input.txi}
	"""
#+end_src

#+begin_src bash :tangle ./scripts/make_rna_batch_corrections.R
#!/usr/bin/env Rscript

# ---   Setup   --- #
# ----------------- #

## ---   Load Packages   --- ##
## ------------------------- ##

library(optparse)
library(cowplot)
library(edgeR)
library(gridExtra)
library(ggrepel)
library(patchwork)
library(sva)
library(tidyverse)

## ---   Load Inputs   --- ##
## ----------------------- ##

option_list <- list(
  make_option(c("--batch_var"), type = "character", default = "run"),
  make_option(c("--covars"), type = "character", default = "cohort"),
  make_option(c("--design_rds"), type = "character", default = "~/cards/analysis/rna/models/hrt/design.rds"),
  make_option(c("--dge_rds"), type = "character", default = "/tmp/dge.rds"),
  make_option(c("--glm_rds"), type = "character", default = "/tmp/glm.rds"),
  make_option(c("--libraries_full_rds"), type = "character", default = "~/cards/data-model/lists/libraries_full.rds"),
  make_option(c("--adjusted_rds"), type = "character", default = "/tmp/adjusted.rds"),
  make_option(c("--pdf"), type = "character", default = "/tmp/adjusted.pdf"),
  make_option(c("--txi_rds"), type = "character", default = "~/cards/analysis/rna/models/hrt/txi.rds")
)

opts <- parse_args(OptionParser(option_list = option_list))

list_of_options <- names(opts)
for (opt_name in list_of_options) {
  assign(opt_name, opts[[opt_name]], envir = .GlobalEnv)
}

design <- readRDS(design_rds)
libraries_full <- readRDS(libraries_full_rds)
txi <- readRDS(txi_rds)
counts <- txi$counts

batch <- data.frame(library = colnames(counts)) %>%
  left_join(libraries_full, by = "library") %>%
  pull(!!sym(batch_var)) %>%
  as.factor() %>%
  as.integer()

covars_vect <- unlist(strsplit(covars, " "))

# ---   Perform Combatseq   --- #
# ----------------------------- #

# Check if there is only one covariate
if (length(covars_vect) == 1) {
  covar <- data.frame(library = colnames(counts)) %>%
    left_join(libraries_full, by = "library") %>%
    pull(!!sym(covars_vect[1])) %>%
    as.factor() %>%
    as.integer()
  adjusted <- ComBat_seq(counts,
                         batch = batch,
                         group = covar)
} else { # If there are multiple covariates
  covar_list <- list() # Initialize an empty list to store covariate vectors
  for (covar_name in covars_vect) {
    covar <- data.frame(library = colnames(counts)) %>%
      left_join(libraries_full, by = "library") %>%
      pull(!!sym(covar_name)) %>%
      as.factor() %>%
      as.integer()
    covar_list[[covar_name]] <- covar
  }
  # Combine all covariate vectors into a matrix
  covar_mat <- do.call(cbind, covar_list)
  adjusted <- ComBat_seq(counts,
                         batch = batch,
                         group = NULL,
                         covar_mod = covar_mat)
}

# ---   Normalize Adjusted Counts Across Exp Design   --- #
# ------------------------------------------------------- #

make_dge_list <- function( eff_gene_len, counts_mat, design ) {
  normMat <- eff_gene_len
  # Obtaining per-observation scaling factors for length, adjusted to avoid
  # changing the magnitude of the counts.
  normMat <- normMat/exp(rowMeans(log(normMat)))
  normCts <- counts_mat/normMat
  # Computing effective library sizes from scaled counts, to account for
  # composition biases between samples.
  eff.lib <- calcNormFactors(normCts) * colSums(normCts)
  # Combining effective library sizes with the length factors, and calculating
  # offsets for a log-link GLM.
  normMat <- sweep(normMat, 2, eff.lib, "*")
  normMat <- log(normMat)
  # Creating a DGEList object for use in edgeR.
  y <- DGEList(counts_mat)
  y <- scaleOffset(y, normMat)
  keep <- filterByExpr(y, design)
  y <- y[keep, ]
  return(y)
}

y <- make_dge_list(txi$length, adjusted, design)
y <- estimateDisp(y,design)
fit <- glmQLFit(y,design)

logcpm_adjusted <- edgeR::cpm(y, normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2)

logcpm <- edgeR::cpm(make_dge_list(txi$length, txi$counts, design), normalized.lib.sizes = TRUE, log = TRUE, prior.count = 2)

saveRDS(y, dge_rds)
saveRDS(fit, file = glm_rds)

# ---   Make PCAs   --- #
# --------------------- #

find_pca_extents <- function(logcpm1, logcpm2) {
  pca1 <- prcomp(t(as.matrix(logcpm1[,-1])))
  pca2 <- prcomp(t(as.matrix(logcpm2[,-1])))

  combined <- rbind(as.data.frame(pca1$x), as.data.frame(pca2$x))
  xlims <- range(combined$PC1, na.rm = TRUE)
  ylims <- range(combined$PC2, na.rm = TRUE)

  return(list(xlims = xlims, ylims = ylims))
}

extents <- find_pca_extents(logcpm, logcpm_adjusted)

make_pca <- function(logcpm, libraries_full, covars_vect, xlims, ylims) {
  pca <- prcomp(t(as.matrix(logcpm[,-1])))
  pve_pc1 <- round(100 * summary(pca)$importance[2,1])
  pve_pc2 <- round(100 * summary(pca)$importance[2,2])
  pca_plot <- as.data.frame(pca$x) %>%
    rownames_to_column(var = "library") %>%
    left_join(libraries_full, by = "library") %>%
    ggplot(aes(x = PC1, y = PC2, label = library, color = !!sym(covars_vect[[1]]))) +
    geom_point(size = 4) +
    geom_text_repel() +
    xlab(paste("PC1, ", pve_pc1, "% variance explained", sep ="")) +
    ylab(paste("PC2, ", pve_pc2, "% variance explained", sep ="")) +
    coord_fixed(ratio = 1) +
    xlim(xlims) +
    ylim(ylims)

  return(pca_plot)
}

pca <- make_pca(logcpm, libraries_full, covars_vect, extents$xlims, extents$ylims)
adjusted_pca <- make_pca(logcpm_adjusted, libraries_full, covars_vect, extents$xlims, extents$ylims)

combined_plot <- (pca + ggtitle("Unadjusted")) + (adjusted_pca + ggtitle("Adjusted")) +
                 plot_layout(guides = 'collect') & theme(legend.position = 'bottom')

pdf(pdf, width = 14, height =7, title = "combined plot")
combined_plot
dev.off()

#+end_src

*** Workflow 3: Differential expression contrasts

Workflow 2 receives a curated list RNA-seq library IDs and associcated experimental design for differential gene expression workup.

**** EdgeR Additive Differential Expression Constrast
#+begin_src snakemake
rule make_edger_contrast_de:
    input:
        design = lambda wildcards: f"{rna_dir}/models/{dge_map[wildcards.contrast]['correction']}/{dge_map[wildcards.contrast]['model']}/design.rds",
        fit = lambda wildcards: f"{rna_dir}/models/{dge_map[wildcards.contrast]['correction']}/{dge_map[wildcards.contrast]['model']}/edger_fit.rds",
        annotation_tsv = lambda wildcards: f"{ref_dir}/{dge_map[wildcards.contrast]['build']}_wtrans_annotation.tsv",
    log: f"{log_dir}/{{contrast}}_make_edger_contrast_de.log",
    output: f"{rna_dir}/contrasts/{{contrast}}/edger_dge.tsv",
    params:
        cohorts_str = lambda wildcards: dge_map[wildcards.contrast]['cohorts_str'],
        script = f"{rna_script_dir}/make_edger_contrast_de.R",
    shell:
        """
        Rscript {params.script} \
        --annotation_tsv {input.annotation_tsv} \
        --cohorts_str "{params.cohorts_str}" \
        --design_rds {input.design} \
        --fit_rds {input.fit} \
        --res_tsv {output} > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/make_edger_contrast_de.R
#!/usr/bin/env Rscript

# ---   Setup   --- #
# ----------------- #

## ---   Load Packages   --- ##
## ------------------------- ##

library(edgeR)
library(optparse)
library(tidyverse)

## ---   Load Inputs   --- ##
## ----------------------- ##

option_list <- list(
  make_option(c("--annotation_tsv"), type = "character", default = "~/cards/ref/mm10_wtrans_annotation.tsv"),
  make_option(c("--cohorts_str"), type = "character", default = "cohortgy25_d1 cohortgy0_d1"),
  make_option(c("--design_rds"), type = "character", default = "~/cards/analysis/rna/models/combat/hrt/design.rds"),
  make_option(c("--fit_rds"), type = "character", default = "~/cards/analysis/rna/models/combat/hrt/edger_fit.rds"),
  make_option(c("--res_tsv"), type = "character", default = "/tmp/test.tsv"))

opts <- parse_args(OptionParser(option_list = option_list))

list_of_options <- names(opts)
for (opt_name in list_of_options) {
  assign(opt_name, opts[[opt_name]], envir = .GlobalEnv)
}

design = readRDS(design_rds)
fit = readRDS(fit_rds)
annotation = read_tsv(annotation_tsv)


cohorts_vec = strsplit(cohorts_str, " ")[[1]]
contrast_string <- paste(cohorts_vec[[1]], "-", cohorts_vec[[2]])

contrast <- makeContrasts(eval(parse(text = contrast_string)), levels=design)

qlf = glmQLFTest(fit, contrast = contrast)

res =
  as.data.frame(topTags(qlf, n = Inf)) %>%
  rownames_to_column(var = "ensembl_gene_id") %>%
  as_tibble() %>%
  left_join(annotation, by = "ensembl_gene_id") %>%
  mutate(sign = sign(logFC)) %>%
  mutate(score = sign * -log10(PValue)) %>%
  mutate(rank = rank(-score, ties.method = "random"))

write_tsv(res, file = res_tsv)

#+end_src

**** Volcano plot
#+begin_src snakemake
rule rna_volcano:
    input: f"{rna_dir}/contrasts/{{contrast}}/edger_dge.tsv",
    log: f"{log_dir}/{{contrast}}_rna_volcano.log",
    output: f"{rna_dir}/contrasts/{{contrast}}/volcano.pdf",
    params: script = f"{rna_script_dir}/rna_volcano.R",
    shell:
        """
        Rscript {params.script} \
        {input} \
        {output} \
        > {log} 2>&1
        """
#+end_src
#+begin_src R :tangle ./scripts/rna_volcano.R
#!/usr/bin/env Rscript

################################
###   Rna-Seq Volcano Plot   ###
################################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
dge_tsv = args[1]
out_pdf = args[2]

library(tidyverse)
library(ggrepel)

dge = read_tsv(dge_tsv)

table =
  dge %>%
  mutate(FDR_filtered = ifelse(abs(logFC) > 2, FDR, NA)) %>%
  # Create a column with the rank of each row, when ordered by FDR_filtered
  mutate(rank = rank(FDR_filtered, na.last = "keep")) %>%
  # Create the 'tolabel' column based on the rank column
  mutate(label = ifelse(rank <= 10 & !is.na(rank), external_gene_name,NA)) %>%
  mutate(sig = ifelse(FDR < 0.05 & abs(logFC) > 1, "Sig", "Not sig"))

plot = ggplot(table, aes(x = logFC, y = -log10(FDR), label = label)) +
  geom_point(aes(color = sig)) +
  scale_color_discrete(guide = "none") +
  geom_vline(xintercept = c(1,-1), linetype = "dashed") +
  geom_hline(yintercept = 1.3, linetype = "dashed") +
  geom_label_repel(box.padding = 1, show.legend = F) +
  theme_minimal() +
  ylab(expression(paste(-log["10"]*" ",italic("p")))) +
  xlab("Log-fold Change") +
  ggtitle("")

ggsave(plot, file = out_pdf)
#+end_src
**** GSEA
#+begin_src snakemake
rule gsea_from_edger:
    input: f"{rna_dir}/contrasts/{{contrast}}/edger_dge.tsv",
    log: f"{log_dir}/{{contrast}}_{{pathset}}_gsea_from_edger.log",
    output:
       f"{rna_dir}/contrasts/{{contrast}}/gsea_{{pathset}}.tsv",
       f"{rna_dir}/contrasts/{{contrast}}/gsea_{{pathset}}.xlsx",
    params: script = f"{rna_script_dir}/gsea_from_edger.R",
    shell:
        """
        Rscript {params.script} {input} {wildcards.pathset} {output} > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle ./scripts/gsea_from_edger.R
# Script to make a gsea table from edgeR results and msigdb pathways

# For unit testing
## results_file = "/mnt/ris/jschwarz/Active/cardiac-radiobiology/analysis/wtrans/human_ir2w-sham_edger_results.tsv"
## msig_str = "human_C2_CP:KEGG"
## enrichment_file = "/tmp/test.tsv"

# Command line arguments
args = commandArgs(trailingOnly = TRUE)

results_tsv = args[1]
msig_str = args[2]
enrichment_tsv = args[3]
enrichment_xlsx = args[4]

# Load necessary libraries
library(fgsea)
library(msigdbr)
library(tidyverse)
library(writexl)

results = read_tsv(results_tsv)
rank_tib = results %>%
  filter(F > 0) %>%
  mutate(SN = abs(logFC) / sqrt(1/F)) %>%
  arrange(desc(SN))
rank = rank_tib %>% pull(rank)
names(rank) = rank_tib$ensembl_gene_id
rank = rank[!duplicated(names(rank))]

msig_vect = as.character(unlist(strsplit(msig_str, "_")))

make_pathway_set = function(msig){
  # Pull in pathway set from MSigDb
  if (length(msig) == 2) {
    tib = msigdbr(msig[1], msig[2])
  } else {
    tib = msigdbr(msig[1], msig[2], msig[3])
  }
  pathways = split(as.character(tib$ensembl_gene), tib$gs_name)
  return(pathways)
}

pathway_set = make_pathway_set(msig_vect)

# str(head(pathway_set))

run_fgsea = function(pathways, stats){
  gsea = fgseaMultilevel(pathways = pathways,
                         stats = stats,
                         scoreType = "pos")
  gsea = as_tibble(gsea) %>%
    mutate(leadingEdge = sapply(leadingEdge, paste, collapse = ",")) %>% arrange(padj, pval, -ES)
  return(gsea)
}

enrichment = run_fgsea(pathway_set, rank)
#enrichment

write_tsv(enrichment, enrichment_tsv)
write_xlsx(enrichment, enrichment_xlsx)
#+end_src

*** [[id:9dfffdc1-8c5c-4e29-8498-cbd440270c46][Development]]
*** [[*Ideas][Ideas]]
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
** Ideas
:PROPERTIES:
:ID:       ef8206ca-78a1-49f4-b9f5-23d9209fadd8
:END:
- varaiance partition https://bioconductor.org/packages/devel/bioc/vignettes/variancePartition/inst/doc/variancePartition.pdf
- qualimap post-alignment QC on all  http://qualimap.bioinfo.cipf.es/doc_html/index.html
- splice junction saturation
- CPM sex determination https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6947224/
- re-run salmon with decoy-aware index
- get test data
  #+begin_src bash
repo=~/repos/rna-seq
# get salmon files

cp ~/card/inputs/Rentschler_s4630_MGI0042/1-ir.AACATCTCGA-TATTCGCCAG/1-ir.AACATCTCGA-TATTCGCCAG.quant.sf ${repo}/test/inputs/exp1.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/2-ir.GTAACGTCAC-ACCAACTAAG/2-ir.GTAACGTCAC-ACCAACTAAG.quant.sf ${repo}/test/inputs/exp2.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/3-ir.GCTAACCGTG-TCACCATAAG/3-ir.GCTAACCGTG-TCACCATAAG.quant.sf ${repo}/test/inputs/expsample3.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/10-ct.TCATCCGTGA-TTAGGAGGAA/10-ct.TCATCCGTGA-TTAGGAGGAA.quant.sf ${repo}/test/inputs/ctrl.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/9-ct.TCCAGAATGT-TGGTCCAATT/9-ct.TCCAGAATGT-TGGTCCAATT.quant.sf ${repo}/test/inputs/ctrl2.quant.sf

cp ~/card/inputs/Rentschler_s4630_MGI0042/8-ct.CCGAACATGT-ACCTCATTGA/8-ct.CCGAACATGT-ACCTCATTGA.quant.sf ${repo}/test/inputs/normal.quant.sf
#+end_src
- file:test/inputs/libraries.tsv
  | library | basename            | participant | run  | group |
  |---------+---------------------+-------------+------+-------|
  | lib001  | ctrl.quant.sf       | subj001     | seq1 | ctrl  |
  | lib002  | ctrl2.quant.sf      | subj002     | seq2 | ctrl  |
  | lib003  | normal.quant.sf     | subj003     | seq1 | ctrl  |
  | lib004  | exp1.quant.sf       | subj004     | seq2 | exp   |
  | lib005  | exp2.quant.sf       | subj005     | seq1 | exp   |
  | lib006  | expsample3.quant.sf | subj006     | seq2 | exp   |
*** Snakemake configuration YAML
#+begin_src bash :tangle ./config/int_test.yaml
experiment_id: inttest_human
txdb: "TxDb.Mmusculus.UCSC.mm10.ensGene",
threads: 4
rna_container: "/home/jeszyman/sing_containers/rna.1.2.0.sif"
datadir: "test"
rna_repo: "/home/jeszyman/repos/rna-seq"
factor_str: "run group"
#+end_src
*** [[file:workflow/int_test.smk][Integration testing]]                                                 :smk:
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
**** Preamble
#+begin_src snakemake
#########1#########2#########3#########4#########5#########6#########7#########8
###                                                                          ###
###               Integration Testing Snakefile for RNA-seq                  ###
###                                                                          ###
#########1#########2#########3#########4#########5#########6#########7#########8

##################################
###   Load Required Packages   ###
##################################

import numpy as np
import os
import pandas as pd
import re

#+end_src
**** Variable naming
#+begin_src snakemake

###########################
###   Variable Naming   ###
###########################

# Names directly from configuration YAML
threads = config['threads']

# Names build from configuration parameter base
rna_script_dir = config['rna_repo'] + "/scripts"
#+end_src
**** Functions
#+begin_src snakemake
RNA_LIBS = ["lib001", "lib002", "lib003", "lib004"]
#+end_src
**** All rule

- [[file:./scripts/dumbtest.R][Rscript]]
  #+begin_src R :tangle no
#!/usr/bin/env Rscript

############
###      ###
############

# For unit testing


# Command line arguements
args = commandArgs(trailingOnly = TRUE)
out= args[1]

# Load required packages
library(tidyverse)

test = data.frame(top=c(1,2,3),
                  bottom=c('a','b','c'))

test2 = as_tibble(test)

write_tsv(test2, file = out)
#+end_src
**** Benchmark aggregation
**** Includes statements
**** Bulk RNA-seq Exploratory Data Analysis Integration Testing         :smk:
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
***** Preamble
#+begin_src snakemake
#print("Integration testing snakefile for bulk RNA-seq\n")

# Import common packages
import pandas as pd
import re
import numpy as np

#+end_src
***** Variable naming
#+begin_src snakemake
datadir = config["datadir"]
inputs=datadir + "/inputs"
analysis = datadir + "/analysis"
salmon = analysis + "/salmon"
results = datadir + "/results"
factor_str= config["factor_str"]
rna_container = config["rna_container"]
logdir = config["datadir"] + "/logs"

rna_repo = config["rna_repo"]
rna_scriptdir = rna_repo + "/scripts"
library_tsv=inputs + "/libraries.tsv"
#+end_src
***** Functions, miscellaneous
#+begin_src snakemake
rna_libraries = pd.read_table(inputs + "/libraries.tsv")
rna_libraries["path"]= inputs + "/" + rna_libraries["basename"]

# Needs full path to work (no tilda)
readable = []
for x in rna_libraries.path:
    readable.append(os.access(x, os.R_OK))
rna_libraries['readable']=readable

rna_libraries = rna_libraries[rna_libraries.readable == True]

rna_library_indict = rna_libraries["library"].tolist()
rna_file_indict = rna_libraries["path"].tolist()
rna_lib_dict = dict(zip(rna_library_indict, rna_file_indict))

BULK_RNA_LIBS = list(rna_lib_dict.keys())

#+end_src
***** All rule

***** Symlink inputs                                               :smk_rule:
- Snakemake
  #+begin_src snakemake
rule symlink_salmon:
    container: rna_container,
    input: lambda wildcards: rna_lib_dict[wildcards.library],
    log: logdir + "/{library}_symlink_salmon.log",
    output: salmon + "/{library}.quant.sf",
        salmon = lambda wildcards: expand(f"{rna_dir}/salmon/{{library}}_{{build}}/quant.sf",
                                          library = rna_map[wildcards.experiment]['libs'],
                                          build = rna_map[wildcards.experiment]['build']),
        gtf = lambda wildcards: f"{ref_dir}/{rna_map[wildcards.experiment]['build']}_wtrans.gtf.gz",
    log: f"{log_dir}/{{experiment}}_make_salmon_txi.log",
    output: f"{rna_dir}/models/{{experiment}}_edger/txi.rds",
    params:
        script = rna_scriptdir + "/symlink_salmon.sh"
    shell:
        """
        {params.script} {input} {output} &> {log}
        """
#+end_src
- Shell
  #+begin_src bash :tangle no
#!/usr/bin/env bash
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

variables(){
   in_salmon="${1}"
   out_sym="${2}"
}

main(){
    variables $@
    ln --force --relative --symbolic $in_salmon $out_sym
}

main "$@"

#+end_src
***** Include statements
#+begin_src snakemake
include: rna_repo + "/workflow/rna_seq_eda.smk"
#+end_src

**** Post-QC RNA-seq Differential Expression                            :smk:
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
***** Preamble
#+begin_src snakemake
print("Integration testing snakefile for Post-QC RNA-seq Differential Expression\n")

# Import common packages
import pandas as pd
import re
import numpy as np

#+end_src
***** Variable naming
#+begin_src snakemake

#+end_src
***** Functions, miscellaneous
#+begin_src snakemake

#+end_src
***** All rule
#+begin_src snakemake
rule all:
    input:
        design
        tmm
        ebayes
        dds
#+end_src
***** Symlink inputs
#+begin_src snakemake
rule symlink_rnaseq_de_inputs:
    input:
        design = f"{rna_dir}/models/{{experiment}}_edger/design.rds",
        txi = f"{rna_dir}/models/{{experiment}}_edger/txi.rds",
    log: f"{log_dir}/{{experiment}}_norm_txi_edger.log",
    output:
        dge = f"{rna_dir}/models/{{experiment}}_edger/dge.rds",
        glm = f"{rna_dir}/models/{{experiment}}_edger/fit.rds",
        cpm = f"{rna_dir}/models/{{experiment}}_edger/cpm.tsv",
    params: script = f"{rna_script_dir}/norm_txi_edger.R",
    shell:
        """
        Rscript {params.script} \
        {input.design} \
        {input.txi} \
        {output.dge} \
        {output.glm} \
        {output.cpm} \
        > {log} 2>&1
        """
#+end_src

#+begin_src R :tangle no
#!/usr/bin/env Rscript

#######################
###   Human Edger   ###
#######################

# Command line arguements
args = commandArgs(trailingOnly = TRUE)
design_rds = args[1]
txi_rds = args[2]
dge_rds = args[3]
glm_rds = args[4]
logcpm_tsv = args[5]


#+end_src
***** Include statements
#+begin_src snakemake
#include: " <INCLUDE FILE LOCATION (VIA CONFIG PARAM)>"
#+end_src
*** Tables
- Rscript
  #+begin_src R
library(DESeq2)
library(tidyverse)

libraries_full_rds="~/cards/data-model/libraries_full.rds"
libraries_full = readRDS(libraries_full_rds)
mouse_nuc_txi_rds = "~/cards/analysis/rna/de/mouse_nuc_bulk_mm10_protein_coding.txi"
mouse_nuc_txi = readRDS(mouse_nuc_txi_rds)
mouse_nuc_libs = data.frame(library = colnames(mouse_nuc_txi$counts)) %>%
  left_join(libraries_full) %>% droplevels(.)
mouse_nuc_dds = DESeqDataSetFromTximport(mouse_nuc_txi, mouse_nuc_libs, ~ post_ir_d + run)
mouse_nuc_dds = DESeq(mouse_nuc_dds)
mouse_nuc_dge_d42 = as.data.frame(results(mouse_nuc_dds, contrast = c("post_ir_d", "42", "-1"))) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

all = mouse_nuc_dge_d42 %>% filter(padj < 0.05) %>% tally
down = mouse_res_d42 %>% filter(padj < 0.05) %>% filter(log2FoldChange < 0) %>% tally
100*down/all

#########1#########2#########3#########4#########5#########6#########7#########8

library(fgsea)
library(msigdbr)

rank = mouse_nuc_dge_d42 %>% group_by(ensembl) %>% slice_max(baseMean) %>% ungroup() %>%
  mutate(rank = sign(log2FoldChange)  * -log10(pvalue)) %>%
  mutate(rank = rank(rank, ties.method="random")) %>% arrange(-rank)
ranklist = rank$rank
names(ranklist) = rank$ensembl

ms_hal = msigdbr(species = "mouse", category = "H")
fgsea_lists = split(as.character(ms_hal$ensembl_gene),ms_hal$gs_name)
gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)
gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)

ms_tft = msigdbr("mouse", category = "C3", subcategory = "TFT:GTRD")
fgsea_lists = split(as.character(ms_tft$ensembl_gene),ms_tft$gs_name)
gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)
gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)

ms_tft = msigdbr("mouse", category = "C2", subcategory = "CP:KEGG")
fgsea_lists = split(as.character(ms_tft$ensembl_gene),ms_tft$gs_name)
gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)
gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)

#########1#########2#########3#########4#########5#########6#########7#########8

# enriched at time zero
rank = mouse_nuc_dge_d42 %>% group_by(ensembl) %>% slice_max(baseMean) %>% ungroup() %>%
  mutate(rank = -sign(log2FoldChange)  * -log10(pvalue)) %>%
  mutate(rank = rank(rank, ties.method="random")) %>% arrange(-rank)
ranklist = rank$rank
names(ranklist) = rank$ensembl

ms_hal = msigdbr(species = "mouse", category = "H")
fgsea_lists = split(as.character(ms_hal$ensembl_gene),ms_hal$gs_name)
gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)
gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)

ms_tft = msigdbr("mouse", category = "C3", subcategory = "TFT:GTRD")
fgsea_lists = split(as.character(ms_tft$ensembl_gene),ms_tft$gs_name)
gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)
gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)



ms_tft = msigdbr("mouse", category = "C2", subcategory = "CP:KEGG")
fgsea_lists = split(as.character(ms_tft$ensembl_gene),ms_tft$gs_name)
gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)
gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)

#+end_src
#+begin_src snakemake
rule make_cpm_pca:
    input:
        cpm = f"{rna_dir}/models/{{experiment}}_edger/cpm.tsv",
        libraries_full = libraries_full_rds,
    log: f"{log_dir}/{{experiment}}_make_cpm_pca.log",
    output:
        f"{rna_dir}/models/{{experiment}}_edger/pca.png",
        f"{rna_dir}/models/{{experiment}}_edger/pca.svg",
    params:
        formula = lambda wildcards: rna_map[wildcards.experiment]['formula'],
        script = f"{rna_script_dir}/make_cpm_pca.R",
    shell:
        """
        Rscript {params.script} \
        {input.cpm} \
        "{params.formula}" \
        {input.libraries_full} \
        {output} > {log} 2>&1
        """
#+end_src


ms_hal = msigdbr(species = "mouse", category = "H")

fgsea_lists = split(as.character(ms_hal$ensembl_gene),ms_hal$gs_name)

gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)

gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.05)

ms_tft = msigdbr("mouse", category = "C3", subcategory = "TFT:GTRD")

fgsea_lists = split(as.character(ms_tft$ensembl_gene),ms_tft$gs_name)

gsea = fgseaMultilevel(pathways = fgsea_lists,
                       stats = ranklist,
                       scoreType = "pos",
                       nPermSimple = 10000)

gsea %>% as_tibble() %>% arrange(padj) %>% filter(padj < 0.1)


gsea = fgsea(pathways = fgsea_lists,
             stats = ranklist,
             scoreType = "pos",
             nP)




test %>% filter(log2FoldChange > 0) %>% filter(padj < 0.05) %>% tally()

human_res_d7 = as.data.frame(results(human_dds, contrast = c("group", "gy25_post_ir_d7", "gy0_post_ir_d7"))) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

resultsNames(mouse_nuc_dds)




mouse_wtrans_txi = "~/cards/analysis/rna/de/mouse_hrt_wtrans_mm10_protein_coding.txi"
txi = readRDS(mouse_wtrans_txi)

(libraries_txi = data.frame(library = colnames(txi$counts)))
libraries_txi = libraries_txi %>% left_join(libraries_full) %>% droplevels(.)

mouse_wtrans_dds = DESeqDataSetFromTximport(txi, libraries_txi, ~ post_ir_d + run)
mouse_wtrans_dds = DESeq(mouse_wtrans_dds)



#########1#########2#########3#########4#########5#########6#########7#########8

res %>% filter(padj < 0.05)
head(res)

res <- results(dds, contrast=c("condition","treated","untreated"))

dds = DESeq(dds, test="LRT", reduced = reduced)


args = commandArgs(trailingOnly = TRUE)
libraries_full_rds=args[1]
txi_rds=args[2]
factor_str=args[3]
dds_rds=args[4]

library(DESeq2)
library(tidyverse)
libraries_full = readRDS(libraries_full_rds)
txi = readRDS(txi_rds)

(factor_char = unlist(strsplit(factor_str, " ")))

libraries_full$group <- apply(libraries_full[, factor_char], 1, function(x) {
  prefix <- paste0(factor_char[1], x[1])
  suffix <- paste0("_", paste0(factor_char[2:length(factor_char)], x[2:length(x)]), collapse = "_")
  paste0(prefix, suffix)
})

libraries_full$group = as.factor(libraries_full$group)

(libraries_txi = data.frame(library = colnames(txi$counts)))
libraries_txi = libraries_txi %>% left_join(libraries_full)

dds = DESeqDataSetFromTximport(txi, libraries_txi, ~group)
dds <- DESeq(dds)

saveRDS(dds, dds_rds)


#########1#########2#########3#########4#########5#########6#########7#########8

libraries_full_rds = "~/cards/data-model/libraries_full.rds"
human_dds_rds = "~/cards/analysis/rna/de/human_icell_wtrans_hg38_singf_lrt_deseq.rds"
mouse_wtrans_dds_rds = "~/cards/analysis/rna/de/mouse_hrt_wtrans_mm10_day_deseq.rds"
mouse_nuc_dds_rds = "~/cards/analysis/rna/de/mouse_nuc_bulk_mm10_singf_lrt_deseq.rds"

#!/usr/bin/env Rscript

##################################
###   Rna-Seq Results Tables   ###
##################################

# Load required packages and data
library(DESeq2)
library(tidyverse)
library(biomaRt)

libraries_full = readRDS(libraries_full_rds)
txi = readRDS(txi_rds)
human_dds = readRDS(human_dds_rds)
mouse_wtrans_dds = readRDS(mouse_wtrans_dds_rds)

human_res_d7 = as.data.frame(results(human_dds, contrast = c("group", "gy25_post_ir_d7", "gy0_post_ir_d7"))) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

human_res_d14 = as.data.frame(results(human_dds, contrast = c("group", "gy25_post_ir_d14", "gy0_post_ir_d14")))%>% rownames_to_column(var = "ensembl") %>% as_tibble()

mouse_wtrans_d1vsham = as.data.frame(results(mouse_wtrans_dds, contrast=c("post_ir_d","1","-1"))) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

mouse_wtrans_d14vsham = as.data.frame(results(mouse_wtrans_dds, contrast=c("post_ir_d","14","-1"))) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

mouse_wtrans_d42vsham = as.data.frame(results(mouse_wtrans_dds, contrast=c("post_ir_d","42","-1"))) %>% rownames_to_column(var = "ensembl") %>% as_tibble()

mouse_nuc_d42vsham = as.data.frame(results(mouse_nuc_dds, contrast = c("post_ir_d", "42", "-1"))) %>%
  rownames_to_column(var = "ensembl") %>% as_tibble()

ensembl_gene_vect = human_res_d7$ensembl
mart = useDataset("hsapiens_gene_ensembl", useMart("ensembl"))
#https://www.biostars.org/p/149115/

test = listAttributes(mart, page = "homologs")
names(test)

test %>% filter(grepl("Human", description))

annotation = getBM(
  filters = "ensembl_gene_id",
  attributes=c("ensembl_gene_id",
               "entrezgene_id",
               "description",
               "external_gene_name",
               "gene_biotype",
               "mmusculus_homolog_ensembl_gene"),
  values = ensembl_gene_vect,
  mart =  mart)

annotation = getBM(
  filters = "ensembl_gene_id",
  attributes=c("mmusculus_homolog_ensembl_gene",
               "hsapiens_homolog_ensembl_gene"),
  values = ensembl_gene_vect,
  mart =  mart)

head(annotation)

nrow(annotation)
length(ensembl_gene_vect)
genevect = rownames(res)

make_annotation = function(ensembl_gene_vect, species){
  # Define species mart
  martdataset = ifelse(species == "human", "hsapiens_gene_ensembl", "mmusculus_gene_ensembl")

  # Fetch organism appriopriate Ensembl data mart
  mart = useDataset(martdataset, useMart("ensembl"))

  # Make the annotation dataframe
  annotation = getBM(
    filters = "ensembl_gene_id",
    attributes=c("ensembl_gene_id",
                 "entrezgene_id",
                 "description",
                 "external_gene_name",
                 "gene_biotype"),
    values = ensembl_gene_vect,
    mart = mart)

  annotation = as_tibble(annotation)

  return(annotation)
}

annotation = make_annotation(genevect, human)



entrez <- getBM(
  filters="ensembl_gene_id",
    attributes=c("ensembl_gene_id",
               "entrezgene_id",
               "description",
               "external_gene_name",
               "gene_biotype"),
  values = res,
  mart = mart)

entrez %>% arrange(external_gene_name)


test = readRDS("~/cards/analysis/rna/de/human_icell_wtrans_hg38_singf_lrt_deseq.rds")
test

test$group

res = results(test, contrast=c("group","gy25_post_ir_d7", "gy0_post_ir_d7"))
res = as.data.frame(res) %>% filter(padj < 0.1) %>% rownames_to_column(var = "ensembl") %>% pull(ensembl)
  vsd = vst(dds, blind = FALSE)
  mat = assay(vsd)
  mat = mat[rownames(mat) %in% res,]
  scaled_mat = t(scale(t(mat)))

mat = scaled_mat

anno_df = data.frame(library = colnames(mat)) %>% left_join(libraries_full) %>% filter(post_ir_d == 14)

mat = mat[,colnames(mat) %in% anno_df$library]

ha = HeatmapAnnotation(Gy= anno_df$gy,
                       Day = as.numeric(anno_df$post_ir_d),
                       col = list(Gy = c("0" = "blue",
                                         "25" = "red")))
Heatmap(mat, show_row_names = FALSE, top_annotation = ha)


# Note culture batch effect by preparer
# pull out libs <173


res = results(radtest)




head(res[order(res$padj),], 40)

class(res)

test=as.data.frame(res)

results = test %>% rownames_to_column(var = "ensembl_gene_id") %>% left_join(annotation, by = "ensembl_gene_id") %>% as_tibble()

results %>% arrange(padj) %>% filter(padj < 0.05) %>% dplyr::select(external_gene_name, description, log2FoldChange, padj) %>% write_tsv("/tmp/test.tsv")


names(res)
#+end_src

*** Ideas
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
** README
:PROPERTIES:
:export_file_name: ./readme.md
:export_file_options: toc:nil
:END:
Software is managed with conda. A full list of software versions is at [[file:resources/]]

Generated data is abstracted at the levels of reads, alignments, models, and differential expression contrasts.

Model directories contain normalized counts, model fits, and standardized exploratory data analysis.

Model directories suffixes with _combat are batch corrected using ComBat-seq.

Contrast directories reference a specific model fit to general diffwrentiale fit models

*** Pipeline Directed Acyclic Graphs
*** Prerequisites for local integration testing
- See configuation file (./config/int_test.yaml) for required parameters and versioned singularity container
*** Changelog
- [2022-10-28 Fri] Stable 1.0.1 libraries_tsv naming abstracted
- [2022-10-28 Fri] Stable 1.0.0 Basic edgeR run
>>>>>>> f1b55e3... .

*** Ideas                                                             :ideas:
- cibersort
** Reference :ref:
- https://github.com/zhxiaokang/RASflow/blob/master/scripts/dea_genome.R
*** [[id:4206be38-8d3c-43c4-a5c7-ca6a8bd8361a][Bulk RNA-seq processes in biotools]]
*** [[id:3b95fbca-3d9a-479c-9285-f8f328c5114f][RNA-seq complete pipeline examples]]
